<html><head><base href="https://websim.ai/games/3d-boxing/">
<title>3D Boxing Game - Improved with Blood Effects</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
<style>
body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
#gameCanvas { width: 100%; height: 100%; }
#gameUI { position: absolute; top: 10px; left: 0; right: 0; color: white; display: none; text-align: center; }
#healthBars { display: flex; justify-content: space-between; margin: 0 20px; }
.healthBar { width: 200px; height: 20px; background-color: #333; border: 2px solid #fff; }
.healthFill { height: 100%; transition: width 0.3s; }
#playerHealthFill { background-color: #00f; width: 100%; }
#opponentHealthFill { background-color: #f00; width: 100%; }
#controls { margin-top: 10px; }
#startScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; }
#startButton { font-size: 24px; padding: 10px 20px; cursor: pointer; }
#gameOverScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; flex-direction: column; }
#gameOverText { font-size: 48px; color: white; margin-bottom: 20px; }
#restartButton { font-size: 24px; padding: 10px 20px; cursor: pointer; }
</style>
</head>
<body>
<div id="gameUI">
  <div id="healthBars">
    <div class="healthBar"><div id="playerHealthFill" class="healthFill"></div></div>
    <div class="healthBar"><div id="opponentHealthFill" class="healthFill"></div></div>
  </div>
  <div id="controls">Controls: WASD to move, SPACE to punch, SHIFT to block/crouch</div>
</div>
<div id="startScreen">
  <button id="startButton">Start Game</button>
</div>
<div id="gameOverScreen">
  <div id="gameOverText"></div>
  <button id="restartButton">Restart Game</button>
</div>
<canvas id="gameCanvas"></canvas>

<script>
let scene, camera, renderer, player, opponent, ring;
let playerHealth = 100;
let opponentHealth = 100;
let isBlocking = false;
let canPunch = true;
let gameStarted = false;
const keys = {};

function initGame() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  renderer = new THREE.WebGLRenderer({canvas: document.getElementById('gameCanvas'), antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(0, 10, 5);
  directionalLight.castShadow = true;
  scene.add(directionalLight);

  const ringGeometry = new THREE.BoxGeometry(10, 0.1, 10);
  const ringMaterial = new THREE.MeshPhongMaterial({color: 0x999999});
  ring = new THREE.Mesh(ringGeometry, ringMaterial);
  ring.receiveShadow = true;
  scene.add(ring);

  createRopes();
  createPosts();

  player = createHumanBoxer(0x0000ff);
  player.position.set(-2, 1, 0);
  scene.add(player);

  opponent = createHumanBoxer(0xff0000);
  opponent.position.set(2, 1, 0);
  scene.add(opponent);

  camera.position.set(0, 5, 10);
  camera.lookAt(ring.position);

  document.addEventListener('keydown', onKeyDown);
  document.addEventListener('keyup', onKeyUp);
  window.addEventListener('resize', onWindowResize);

  animate();
}

function createRopes() {
  const ropeHeights = [0.5, 1, 1.5];
  ropeHeights.forEach(height => {
    createRope(-5, -5, 5, -5, height);
    createRope(5, -5, 5, 5, height);
    createRope(5, 5, -5, 5, height);
    createRope(-5, 5, -5, -5, height);
  });
}

function createRope(x1, z1, x2, z2, height) {
  const ropeGeometry = new THREE.CylinderGeometry(0.03, 0.03, 10, 16);
  const ropeMaterial = new THREE.MeshPhongMaterial({color: 0xFFFFFF});
  const rope = new THREE.Mesh(ropeGeometry, ropeMaterial);
  rope.position.set((x1 + x2) / 2, height, (z1 + z2) / 2);
  rope.rotation.y = Math.atan2(z2 - z1, x2 - x1);
  rope.rotation.z = Math.PI / 2;
  rope.castShadow = true;
  scene.add(rope);
}

function createPosts() {
  const postPositions = [[-5, -5], [5, -5], [5, 5], [-5, 5]];
  postPositions.forEach(pos => createPost(pos[0], pos[1]));
}

function createPost(x, z) {
  const postGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2, 16);
  const postMaterial = new THREE.MeshPhongMaterial({color: 0x888888});
  const post = new THREE.Mesh(postGeometry, postMaterial);
  post.position.set(x, 1, z);
  post.castShadow = true;
  scene.add(post);
}

function createHumanBoxer(color) {
  const boxer = new THREE.Group();

  // Body
  const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.25, 1.2, 16);
  const bodyMaterial = new THREE.MeshPhongMaterial({color: color});
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
  body.position.y = 0.6;
  body.castShadow = true;
  boxer.add(body);

  // Head
  const headGeometry = new THREE.SphereGeometry(0.2, 32, 32);
  const headMaterial = new THREE.MeshPhongMaterial({color: 0xFFDAB9});
  const head = new THREE.Mesh(headGeometry, headMaterial);
  head.position.y = 1.5;
  head.castShadow = true;
  boxer.add(head);

  // Legs
  const legGeometry = new THREE.CylinderGeometry(0.1, 0.08, 1, 16);
  const legMaterial = new THREE.MeshPhongMaterial({color: color});
  const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
  leftLeg.position.set(-0.2, -0.5, 0);
  leftLeg.castShadow = true;
  boxer.add(leftLeg);

  const rightLeg = leftLeg.clone();
  rightLeg.position.set(0.2, -0.5, 0);
  boxer.add(rightLeg);

  // Gloves
  const gloveGeometry = new THREE.SphereGeometry(0.15, 32, 32);
  const gloveMaterial = new THREE.MeshPhongMaterial({color: color});
  const leftGlove = new THREE.Mesh(gloveGeometry, gloveMaterial);
  leftGlove.position.set(-0.4, 1, 0.3);
  leftGlove.castShadow = true;
  boxer.add(leftGlove);

  const rightGlove = leftGlove.clone();
  rightGlove.position.set(0.4, 1, 0.3);
  boxer.add(rightGlove);

  return boxer;
}

function onKeyDown(event) {
  keys[event.code] = true;
  if (event.code === 'ShiftLeft') {
    isBlocking = true;
    animateBlock(player, true);
  }
}

function onKeyUp(event) {
  keys[event.code] = false;
  if (event.code === 'ShiftLeft') {
    isBlocking = false;
    animateBlock(player, false);
  }
}

function movePlayer() {
  const speed = 0.05;
  const newPosition = player.position.clone();
  if (keys['KeyW']) newPosition.z -= speed;
  if (keys['KeyS']) newPosition.z += speed;
  if (keys['KeyA']) newPosition.x -= speed;
  if (keys['KeyD']) newPosition.x += speed;
  
  newPosition.x = Math.max(-4.75, Math.min(4.75, newPosition.x));
  newPosition.z = Math.max(-4.75, Math.min(4.75, newPosition.z));
  
  if (newPosition.distanceTo(opponent.position) > 1) {
    player.position.copy(newPosition);
  }
  
  const direction = new THREE.Vector3().subVectors(opponent.position, player.position);
  player.lookAt(player.position.clone().add(direction));
}

function punch(boxer, isPlayer) {
  if ((isPlayer && keys['Space'] && canPunch && !isBlocking) || (!isPlayer && Math.random() < 0.02)) {
    if (isPlayer) {
      canPunch = false;
      setTimeout(() => { canPunch = true; }, 500);
    }

    const punchGlove = Math.random() < 0.5 ? boxer.children[4] : boxer.children[5];
    const originalGlovePosition = punchGlove.position.clone();
    const punchDuration = 100;

    new TWEEN.Tween(punchGlove.position)
      .to({ z: isPlayer ? 0.8 : -0.8 }, punchDuration / 2)
      .easing(TWEEN.Easing.Quadratic.Out)
      .start()
      .onComplete(() => {
        new TWEEN.Tween(punchGlove.position)
          .to(originalGlovePosition, punchDuration / 2)
          .easing(TWEEN.Easing.Quadratic.In)
          .start();
      });

    const distance = player.position.distanceTo(opponent.position);
    if (distance < 1.5) {
      if (isPlayer && !isOpponentBlocking()) {
        opponentHealth -= 10;
        updateHealthBar('opponent', opponentHealth);
        createBloodSplatter(opponent.position);
        if (opponentHealth <= 0) {
          showGameOver("You win!");
        }
      } else if (!isPlayer && !isBlocking) {
        playerHealth -= 10;
        updateHealthBar('player', playerHealth);
        createBloodSplatter(player.position);
        if (playerHealth <= 0) {
          showGameOver("Game Over!");
        }
      }
    }
  }
}

function createBloodSplatter(position) {
  const particleCount = 30;
  const particles = new THREE.Group();
  
  for (let i = 0; i < particleCount; i++) {
    const particle = new THREE.Mesh(
      new THREE.SphereGeometry(0.02 + Math.random() * 0.02, 8, 8),
      new THREE.MeshBasicMaterial({ color: 0x8B0000 })
    );
    
    particle.position.copy(position);
    particles.add(particle);
    
    const direction = new THREE.Vector3(
      Math.random() - 0.5,
      Math.random() * 0.5,
      Math.random() - 0.5
    ).normalize();
    
    const speed = 0.05 + Math.random() * 0.1;
    
    new TWEEN.Tween(particle.position)
      .to({
        x: particle.position.x + direction.x * speed,
        y: particle.position.y + direction.y * speed,
        z: particle.position.z + direction.z * speed
      }, 500)
      .easing(TWEEN.Easing.Quadratic.Out)
      .start()
      .onComplete(() => {
        particles.remove(particle);
      });
    
    new TWEEN.Tween(particle.material)
      .to({ opacity: 0 }, 500)
      .start();
    
    new TWEEN.Tween(particle.scale)
      .to({ x: 0, y: 0, z: 0 }, 500)
      .start();
  }
  
  scene.add(particles);
  setTimeout(() => scene.remove(particles), 500);
}

function moveOpponent() {
  const direction = new THREE.Vector3();
  direction.subVectors(player.position, opponent.position);
  direction.normalize();
  const newPosition = opponent.position.clone().add(direction.multiplyScalar(0.03));
  
  newPosition.x = Math.max(-4.75, Math.min(4.75, newPosition.x));
  newPosition.z = Math.max(-4.75, Math.min(4.75, newPosition.z));
  
  if (newPosition.distanceTo(player.position) > 1) {
    opponent.position.copy(newPosition);
  }
  
  opponent.lookAt(player.position);
}

function isOpponentBlocking() {
  return Math.random() < 0.3;
}

function animateBlock(boxer, isBlocking) {
  const body = boxer.children[0];
  const head = boxer.children[1];
  const leftGlove = boxer.children[4];
  const rightGlove = boxer.children[5];
  
  if (isBlocking) {
    new TWEEN.Tween(body.scale)
      .to({ y: 0.8 }, 100)
      .start();
    new TWEEN.Tween(body.position)
      .to({ y: 0.48 }, 100)
      .start();
    new TWEEN.Tween(head.position)
      .to({ y: 1.3 }, 100)
      .start();
    new TWEEN.Tween(leftGlove.position)
      .to({ y: 1.2, z: 0.5 }, 100)
      .start();
    new TWEEN.Tween(rightGlove.position)
      .to({ y: 1.2, z: 0.5 }, 100)
      .start();
  } else {
    new TWEEN.Tween(body.scale)
      .to({ y: 1 }, 100)
      .start();
    new TWEEN.Tween(body.position)
      .to({ y: 0.6 }, 100)
      .start();
    new TWEEN.Tween(head.position)
      .to({ y: 1.5 }, 100)
      .start();
    new TWEEN.Tween(leftGlove.position)
      .to({ y: 1, z: 0.3 }, 100)
      .start();
    new TWEEN.Tween(rightGlove.position)
      .to({ y: 1, z: 0.3 }, 100)
      .start();
  }
}

function updateHealthBar(boxer, health) {
  const healthFill = document.getElementById(`${boxer}HealthFill`);
  healthFill.style.width = `${health}%`;
}

function showGameOver(text) {
  gameStarted = false;
  document.getElementById('gameOverScreen').style.display = 'flex';
  document.getElementById('gameOverText').textContent = text;
}

function resetGame() {
  playerHealth = 100;
  opponentHealth = 100;
  updateHealthBar('player', playerHealth);
  updateHealthBar('opponent', opponentHealth);
  player.position.set(-2, 1, 0);
  opponent.position.set(2, 1, 0);
  gameStarted = false;
  document.getElementById('startScreen').style.display = 'flex';
  document.getElementById('gameUI').style.display = 'none';
  document.getElementById('gameOverScreen').style.display = 'none';
}

function animate(time) {
  requestAnimationFrame(animate);
  
  if (gameStarted) {
    movePlayer();
    punch(player, true);
    moveOpponent();
    punch(opponent, false);
    
    if (Math.random() < 0.01) {
      animateBlock(opponent, true);
      setTimeout(() => animateBlock(opponent, false), 1000);
    }
  }
  
  TWEEN.update(time);
  renderer.render(scene, camera);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

initGame();

document.getElementById('startButton').addEventListener('click', () => {
  gameStarted = true;
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('gameUI').style.display = 'block';
});

document.getElementById('restartButton').addEventListener('click', resetGame);
</script>
</body></html>