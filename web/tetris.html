<html><head><base href="http://tetris-in-the-browser.com/"><title>Tetris in the Browser</title>
<style>
  body {
    background-color: #111;
    color: #fff;
    font-family: Arial, sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
  }
  #game-container {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #tetris-board {
    width: 300px;
    height: 600px;
    border: 2px solid #fff;
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    grid-template-rows: repeat(20, 1fr);
  }
  .cell {
    border: 1px solid #333;
  }
  .piece {
    border: 1px solid rgba(255, 255, 255, 0.3);
  }
  #score {
    margin-top: 20px;
    font-size: 24px;
  }
  #next-piece {
    width: 120px;
    height: 120px;
    border: 2px solid #fff;
    margin-top: 20px;
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
  }
</style>
</head>
<body>
<div id="game-container">
  <div id="tetris-board"></div>
  <div id="score">Score: 0</div>
  <div id="next-piece"></div>
</div>

<script>
const board = document.getElementById('tetris-board');
const scoreElement = document.getElementById('score');
const nextPieceDisplay = document.getElementById('next-piece');

const BOARD_WIDTH = 10;
const BOARD_HEIGHT = 20;
let score = 0;
let currentPiece;
let nextPiece;
let gameBoard;

const PIECES = [
  [[1, 1, 1, 1]], // I
  [[1, 1], [1, 1]], // O
  [[1, 1, 1], [0, 1, 0]], // T
  [[1, 1, 1], [1, 0, 0]], // L
  [[1, 1, 1], [0, 0, 1]], // J
  [[1, 1, 0], [0, 1, 1]], // S
  [[0, 1, 1], [1, 1, 0]]  // Z
];

const COLORS = ['#00f0f0', '#f0f000', '#a000f0', '#f0a000', '#0000f0', '#00f000', '#f00000'];

function initBoard() {
  gameBoard = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
  for (let y = 0; y < BOARD_HEIGHT; y++) {
    for (let x = 0; x < BOARD_WIDTH; x++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.id = `cell-${y}-${x}`;
      board.appendChild(cell);
    }
  }
}

function drawBoard() {
  for (let y = 0; y < BOARD_HEIGHT; y++) {
    for (let x = 0; x < BOARD_WIDTH; x++) {
      const cell = document.getElementById(`cell-${y}-${x}`);
      cell.style.backgroundColor = gameBoard[y][x] ? COLORS[gameBoard[y][x] - 1] : 'transparent';
    }
  }
}

function createPiece() {
  const pieceIndex = Math.floor(Math.random() * PIECES.length);
  const piece = PIECES[pieceIndex];
  return {
    shape: piece,
    color: pieceIndex + 1,
    x: Math.floor(BOARD_WIDTH / 2) - Math.floor(piece[0].length / 2),
    y: 0
  };
}

function drawPiece(piece) {
  piece.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value) {
        const cellX = piece.x + x;
        const cellY = piece.y + y;
        if (cellY >= 0) {
          const cell = document.getElementById(`cell-${cellY}-${cellX}`);
          if (cell) cell.style.backgroundColor = COLORS[piece.color - 1];
        }
      }
    });
  });
}

function canMove(piece, dx, dy) {
  return piece.shape.every((row, y) => 
    row.every((value, x) => 
      !value || 
      (piece.x + x + dx >= 0 && 
       piece.x + x + dx < BOARD_WIDTH && 
       piece.y + y + dy < BOARD_HEIGHT &&
       !gameBoard[piece.y + y + dy]?.[piece.x + x + dx])
    )
  );
}

function movePiece(dx, dy) {
  if (canMove(currentPiece, dx, dy)) {
    currentPiece.x += dx;
    currentPiece.y += dy;
    drawBoard();
    drawPiece(currentPiece);
    return true;
  }
  return false;
}

function rotatePiece() {
  const rotated = currentPiece.shape[0].map((_, i) => 
    currentPiece.shape.map(row => row[i]).reverse()
  );
  const previousShape = currentPiece.shape;
  currentPiece.shape = rotated;
  if (!canMove(currentPiece, 0, 0)) {
    currentPiece.shape = previousShape;
    return;
  }
  drawBoard();
  drawPiece(currentPiece);
}

function mergePiece() {
  currentPiece.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value) {
        gameBoard[currentPiece.y + y][currentPiece.x + x] = currentPiece.color;
      }
    });
  });
}

function checkLines() {
  let linesCleared = 0;
  for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
    if (gameBoard[y].every(cell => cell !== 0)) {
      gameBoard.splice(y, 1);
      gameBoard.unshift(Array(BOARD_WIDTH).fill(0));
      linesCleared++;
      y++;
    }
  }
  if (linesCleared > 0) {
    score += [40, 100, 300, 1200][linesCleared - 1];
    scoreElement.textContent = `Score: ${score}`;
  }
}

function gameOver() {
  alert(`Game Over! Your score: ${score}`);
  initGame();
}

function updateNextPieceDisplay() {
  nextPieceDisplay.innerHTML = '';
  nextPiece.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.style.backgroundColor = value ? COLORS[nextPiece.color - 1] : 'transparent';
      nextPieceDisplay.appendChild(cell);
    });
  });
}

function gameLoop() {
  if (!movePiece(0, 1)) {
    mergePiece();
    checkLines();
    currentPiece = nextPiece;
    nextPiece = createPiece();
    updateNextPieceDisplay();
    if (!canMove(currentPiece, 0, 0)) {
      gameOver();
      return;
    }
  }
  drawBoard();
  drawPiece(currentPiece);
  setTimeout(gameLoop, 500);
}

function initGame() {
  score = 0;
  scoreElement.textContent = 'Score: 0';
  initBoard();
  currentPiece = createPiece();
  nextPiece = createPiece();
  updateNextPieceDisplay();
  gameLoop();
}

document.addEventListener('keydown', (e) => {
  switch (e.key) {
    case 'ArrowLeft': movePiece(-1, 0); break;
    case 'ArrowRight': movePiece(1, 0); break;
    case 'ArrowDown': movePiece(0, 1); break;
    case 'ArrowUp': rotatePiece(); break;
  }
});

initGame();
</script>
</body></html>