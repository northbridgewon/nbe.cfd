<html lang="en">

<head>
    <base href="xech://game.vampiresimvivors" />
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Vampire Simvivors</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        #game-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            position: relative;
            padding: 20px 0;
        }

        #ui-overlay {
            width: 100%;
            padding: 5px 20px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10;
            position: absolute;
            top: 0;
            left: 0;
        }

        #game-canvas {
            border: 2px solid #f33;
            box-shadow: 0 0 20px #f33;
            margin: 0;
            cursor: crosshair;
        }

        .heart {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 5px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23ff3333"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>');
            background-size: cover;
        }

        .heart-empty {
            opacity: 0.3;
        }

        #game-over,
        #intro-screen,
        #settings-screen,
        #upgrade-screen,
        #cheat-menu,
        #loading-screen,
        #error-screen {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 20;
            width: 80%;
            max-width: 400px;
        }

        #error-screen {
        max-height: 80vh;
        overflow-y: auto;
        z-index: 1000;
    }

        #intro-screen {
            padding-top: 10px;
            padding-bottom: 10px;
        }

        #intro-screen h1 {
            margin-top: 0;
            margin-bottom: 0;
        }

        #game-over h1 {
            font-size: 2em;
            margin-bottom: 20px;
        }

        #version-label {
            position: absolute;
            top: -27px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.1);
            padding: 0px 10px;
            color: #fff;
            font-size: 0.8em;
            box-shadow: 0 0 5px #fff;
            animation: bob 2s infinite;
            white-space: nowrap;
        }

        #play-music-btn {
            display: block;
            margin: 10px auto;
            width: 80px;
        }

        @keyframes bob {

            0%,
            100% {
                transform: translateX(-50%) translateY(0);
            }

            50% {
                transform: translateX(-50%) translateY(-5px);
            }
        }

        .button {
            background: #f33;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            margin-top: 20px;
            width: 100%;
            max-width: 300px;
        }

        .button:hover {
            background: #c00;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        .pulse {
            animation: pulse 1s infinite;
        }

        @keyframes pulse-red {
            0% {
                color: #ff3333;
            }

            50% {
                color: #ffffff;
            }

            100% {
                color: #ff3333;
            }
        }

        .pulse-red {
            animation: pulse-red 3s infinite;
        }

        @keyframes hurt {
            0% {
                background: rgba(255, 0, 0, 0);
            }

            50% {
                background: rgba(255, 0, 0, 0.3);
            }

            100% {
                background: rgba(255, 0, 0, 0);
            }
        }

        .hurt {
            animation: hurt 0.5s;
        }

        #left-stats,
        #right-stats {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        #right-stats {
            align-items: flex-end;
        }

        #health-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        #hearts {
            display: flex;
            justify-content: center;
            padding: 0;
            margin: 0;
            line-height: 1;
        }

        .heart,
        .heart-empty {
            margin: 0;
            padding: 0;
        }

        #prayer-cooldown {
            width: 100%;
            height: 6px;
            background: #444;
            margin-top: 3px;
        }

        #prayer-cooldown-bar {
            width: 0;
            height: 100%;
            background: #4169e1;
            transition: width 0.1s linear;
        }

        #settings-gear {
            position: fixed;
            bottom: 22px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 30px;
            cursor: pointer;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23ff3333"><path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/></svg>');
            background-size: cover;
            z-index: 10;
        }

        .slider-container {
            margin: 10px 0;
            display: flex;
            align-items: center;
        }

        .slider-container label {
            margin-right: 10px;
            width: 150px;
            text-align: right;
        }

        .mobile-only {
            display: none;
        }

        .intro-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            width: 80%;
            max-width: 5px;
            padding-top: 0;
            margin-top: 0;
        }

        @media (max-width: 768px) {
            .intro-container {
                top: 0%;
                font-size: 0em;
            }

            .intro-container h1 {
                margin-top: 0em;
                margin-bottom: 0em;
            }

            .intro-container p {
                margin-top: 0.5em;
                margin-bottom: 0.5em;
            }

            .intro-container .button {
                padding: 0px 0px;
                margin-top: 0px;
            }

            .mobile-only {
                display: block;
            }

            #mobile-health-container {
                position: fixed;
                bottom: 70px;
                left: 50%;
                transform: translateX(-50%);
                display: flex;
                flex-direction: column;
                align-items: center;
                z-index: 10;
            }

            #health-display {
                position: static;
                transform: none;
                left: auto;
            }

            #prayer-cooldown {
                width: 100%;
            }

            #settings-screen {
                top: 300px;
                max-height: 64vh;
                position: fixed;
                overflow-y: scroll;
            }

            #settings-screen .button {
                height: 30px;
                line-height: 30px;
                padding: 0 10px;
                z-index: 10000;
            }

            #settings-screen::-webkit-scrollbar {
                width: 8px;
            }

            #settings-screen::-webkit-scrollbar-track {
                background: rgba(0, 0, 0, 0.8);
            }

            #settings-screen::-webkit-scrollbar-thumb {
                background-color: #f33;
                border-radius: 4px;
            }

            .cheat-item {
                margin-bottom: 30px;
            }

            .cheat-item input[type="number"],
            .cheat-item input[type="range"] {
                height: 30px;
            }

            #game-over,
            #upgrade-screen,
            #error-screen {
                z-index: 2000;
                overflow-y: auto;
                max-height: 80vh;
            }
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 200px;
            height: 10px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
            border-radius: 5px;
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #f33;
            cursor: pointer;
            border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #f33;
            cursor: pointer;
            border-radius: 50%;
        }

        #bottom-info {
            position: fixed;
            bottom: 20px;
            left: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            z-index: 1000;
        }

        #fps-meter {
            position: fixed;
            bottom: 20px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px;
            border-radius: 5px;
            z-index: 1000;
        }

        #xech-banner {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: #555;
            color: #fff;
            text-align: center;
            padding: 2px 0;
            font-size: 10px;
            z-index: 1000;
        }

        #xech-banner a {
            color: #fff;
            text-decoration: underline;
        }

        #upgrade-summary {
            text-align: center;
            margin-left: auto;
            margin-right: auto;
            max-width: 80%;
        }

        #upgrades-list {
            list-style: none;
            padding: 0;
            margin-left: 100px;
            margin-top: 10px;
            text-align: left;
        }

        #upgrade-summary h3 {
            margin-bottom: 5px;
        }

        #upgrade-screen {
            -webkit-user-select: none;
            user-select: none;
        }

        .upgrade-btn.blue-button {
            background: #4169e1;
        }

        .upgrade-btn.blue-button:hover {
            background: #3a5fcf;
        }

        #cheat-menu {
            text-align: left;
        }

        .cheat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .cheat-item input {
            width: 60px;
            text-align: right;
            margin-left: 10px;
        }

        .toast {
            position: fixed;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 16px;
            pointer-events: none;
            transition: opacity 0.5s, transform 0.5s;
            opacity: 1;
            z-index: 1000;
        }

        @keyframes float-up {
            0% {
                transform: translateY(0);
                opacity: 1;
            }

            100% {
                transform: translateY(-50px);
                opacity: 0;
            }
        }

        .float-up {
            animation: float-up 1.5s forwards;
        }

        .yellow-text {
            color: #ff0 !important;
        }

        #cheat-menu h2 {
            text-align: center;
        }

        #loading-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #loading-bar {
            width: 200px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
            position: relative;
        }

        #loading-progress {
            width: 0;
            height: 100%;
            background: #f33;
            transition: width 0.05s linear;
        }

        #loading-percentage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-weight: bold;
        }

        #cheat-back-btn {
            display: block;
            margin: 20px auto 0;
        }

        #controls-description {
            font-size: 14px;
            margin-top: 10px;
            color: #aaa;
        }

        #game-container>*:not(#loading-screen) {
            display: none;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <div id="ui-overlay">
            <div id="left-stats">
                <div>🏆 Score: <span id="score">0</span></div>
                <div>⌚ Time: <span id="time">00:00</span></div>
            </div>
            <div id="health-display">
                <span id="hearts"></span>
                <div id="prayer-cooldown">
                    <div id="prayer-cooldown-bar"></div>
                </div>
            </div>
            <div id="right-stats">
                <div>🥇 High Score: <span id="high-score">0</span></div>
                <div>⏱ Record Time: <span id="record-time">00:00</span></div>
            </div>
        </div>
        <canvas id="game-canvas"></canvas>
        <div id="intro-screen">
            <h1 class="pulse-red">Vampire Simvivors<span id="version-label">v2.1!</span>
            </h1>
            <button id="play-btn" class="button">Play</button>
            <p id="controls-description">
            </p>
            <p><u>Controls</u><br>🏃 Move: Click/Touch<br>🙏 Prayer: Space/Touch<br>⏯ Pause: Escape<br>👁‍🗨 WebSim.ai
                Mobile:
                HIDE MENU</p>
            <p><u>Known Issues</u><br>🍎 No sound on iOS<br>🔇 No music? Click here:<br></p>
            <button id="play-music-btn" class="button mobile-only">🔊</button>
            <p><u>Future Plans</u><br>2️⃣ New level<br>🐺 New enemies<br>👾 New boss<br>💪 New abilities</p>
        </div>
        <div id="settings-screen">
            <h2>Settings</h2>
            <div class="slider-container">
                <label for="music-volume">Music Volume:</label>
                <input type="range" id="music-volume" min="0" max="100" value="66">
            </div>
            <div class="slider-container">
                <label for="sfx-volume">SFX Volume:</label>
                <input type="range" id="sfx-volume" min="0" max="100" value="75">
            </div>
            <div class="slider-container">
                <label for="fps-meter-checkbox">FPS Meter:</label>
                <input type="checkbox" id="fps-meter-checkbox">
                <label for="fps-cap-input">FPS Cap:</label>
                <input type="number" id="fps-cap-input" min="1" max="240" value="" readonly readonly
                    style="background-color: #666666;">
            </div>
            <div id="current-upgrades" style="display: none;">
                <ul id="upgrades-list"></ul>
            </div>
            <h2>😈 Cheats 😈</h2>
            <div class="cheat-item">
                <label for="immortality">💀 Immortality:</label>
                <input type="checkbox" id="immortality">
            </div>
            <div class="cheat-item">
                <label for="health">❤️ Health:</label>
                <input type="range" id="health" min="0" max="5" value="5">
            </div>
            <div class="cheat-item">
                <label for="autopray">🙏 Auto-Pray:</label>
                <input type="checkbox" id="autopray">
            </div>
            <div id="cheat-upgrades"></div>
            <button id="back-btn" class="button">Back</button>
        </div>
        <div id="game-over">
            <h1 class="pulse-red">Game Over</h1>
            <h2>Your Score: <span id="final-score"></span></h2>
            <div id="upgrade-summary" style="text-align:center; margin-top:10px;">
                <h3 style="margin-bottom: 0;">Upgrades Acquired</h3>
                <ul id="upgrades-list" style="display: inline-block; text-align: left;"></ul>
                <p>Bosses Killed: <span id="bosses-killed">0</span></p>
            </div>
            <button id="restart-btn" class="button">Resurrect</button>
        </div>
        <div id="upgrade-screen">
            <h2>Choose an Upgrade</h2>
            <button class="upgrade-btn button" id="upgrade-btn-1"></button>
            <button class="upgrade-btn button" id="upgrade-btn-2"></button>
        </div>
        <div id="loading-screen">
            <h2>Loading...</h2>
            <div id="loading-bar">
                <div id="loading-progress"></div>
                <div id="loading-percentage">0%</div>
            </div>
        </div>
        <div id="settings-gear" style="display: none;"></div>
        <div id="error-screen">
            <h2>Error</h2>
            <p id="error-message"></p>
            <button id="error-back-btn" class="button">Back to Menu</button>
        </div>
    </div>
    <div id="bottom-info">
        <div id="fps-meter" style="display: none;">FPS: <span id="fps-value">0</span></div>
        <div id="xech-banner">
            <a href="https://websim.ai/@Xech" target="_blank" rel="noopener">Made by Xech</a>
        </div>
    </div>
    <script>
        function handleError(error) {
            console.error('An error occurred:', error);
            showError(error);
        }
        function showError(error) {
            console.error('An error occurred:', error);
            const errorScreen = document.getElementById('error-screen');
            const errorMessage = document.getElementById('error-message');
            errorMessage.textContent = `${error.message}\n\n${error.stack}`;
            errorScreen.style.display = 'block';
            const errorBackBtn = document.getElementById('error-back-btn');
            errorBackBtn.onclick = () => {
                errorScreen.style.display = 'none';
                currentState = GameState.INTRO;
                introScreen.style.display = 'block';
            };
            document.getElementById('loading-screen').style.display = 'none';
        }
        const GameState = {
            LOADING: 'loading',
            INTRO: 'intro',
            PLAYING: 'playing',
            PAUSED: 'paused',
            UPGRADING: 'upgrading',
            GAME_OVER: 'gameOver'
        };
        let animationFrameId;
        let currentState = GameState.LOADING;
        let originalGroundPattern;
        const assets = {
            images: {
                groundPattern: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><rect width="100" height="100" fill="%23000000"/><polygon points="25,5 75,5 95,25 95,75 75,95 25,95 5,75 5,25" fill="%23090909"/><rect x="45" y="25" width="10" height="50" fill="%23111111"/><rect x="35" y="50" width="30" height="10" fill="%23111111"/><polygon points="0,0 20,0 0,20" fill="%23330000"/><polygon points="80,0 100,0 100,20" fill="%23330000"/><polygon points="0,80 20,100 0,100" fill="%23330000"/><polygon points="80,100 100,80 100,100" fill="%23330000"/></svg>',
                victoryPattern: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><rect width="100" height="100" fill="%23000000"/><polygon points="75,5 25,5 5,25 5,75 25,95 75,95 95,75 95,25" fill="%23001122"/><rect x="45" y="25" width="10" height="50" fill="%23504006"/><rect x="35" y="50" width="30" height="10" fill="%23504006"/><polygon points="100,100 80,100 100,80" fill="%23000000"/><polygon points="20,100 0,100 0,80" fill="%23000000"/><polygon points="100,20 100,0 80,0" fill="%23000000"/><polygon points="0,20 0,0 20,0" fill="%23000000"/><g transform="rotate(180, 50, 50)"><polygon points="25,5 75,5 95,25 95,75 75,95 25,95 5,75 5,25" fill="%23001122"/><rect x="45" y="25" width="10" height="50" fill="%23504006"/><rect x="35" y="50" width="30" height="10" fill="%23504006"/><polygon points="0,0 20,0 0,20" fill="%23000000"/><polygon points="80,0 100,0 100,20" fill="%23000000"/><polygon points="0,80 20,100 0,100" fill="%23000000"/><polygon points="80,100 100,80 100,100" fill="%23000000"/></g></svg>'
            },
            sounds: {
                click: 'https://cdn.pixabay.com/download/audio/2023/05/29/audio_697c02e935.mp3',
                bulletFire: 'https://cdn.pixabay.com/download/audio/2022/03/19/audio_87d05e5afb.mp3',
                hurt: 'https://cdn.pixabay.com/download/audio/2022/03/24/audio_dba7a37bfe.mp3',
                death: 'https://cdn.pixabay.com/download/audio/2022/03/24/audio_5537314494.mp3',
                enemyDeath: 'https://cdn.pixabay.com/download/audio/2022/12/29/audio_fd4f5e0575.mp3',
                pickup: 'https://cdn.pixabay.com/download/audio/2022/03/15/audio_978c674677.mp3',
                pickupDrop: 'https://cdn.pixabay.com/download/audio/2024/05/23/audio_336d55dfa8.mp3',
                bossSpawn: 'https://cdn.pixabay.com/download/audio/2022/03/10/audio_236c76796f.mp3',
                bossDeath: 'https://cdn.pixabay.com/download/audio/2022/03/17/audio_14b8b157be.mp3',
                bossMusic: 'https://cdn.pixabay.com/download/audio/2022/03/26/audio_ec0023585d.mp3',
                prayer: 'https://cdn.pixabay.com/download/audio/2021/08/04/audio_497dbe031c.mp3',
                upgrade: 'https://cdn.pixabay.com/download/audio/2022/03/10/audio_dd7190e66d.mp3',
                bgMusic: 'https://cdn.pixabay.com/download/audio/2022/06/28/audio_9d694ff17a.mp3',
                victoryMusic: 'https://cdn.pixabay.com/download/audio/2023/09/03/audio_e888b3badd.mp3'
            }
        };
        let loadedAssets = { images: {}, sounds: {} };
        let lastTime = performance.now();
        let lastFrameTime = performance.now();
        let frameCount = 0;
        let fpsDisplayEnabled = false;
        let fpsValue;
        function isTouchDevice() {
            return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
        }
        function handleMobileLayout() {
            const healthDisplay = document.getElementById('health-display');
            const uiOverlay = document.getElementById('ui-overlay');
            const isMobile = window.innerWidth <= 768;
            if (!healthDisplay) {
                console.warn('Health display not found.');
                return;
            }
            let mobileHealthContainer = document.getElementById('mobile-health-container');
            if (isMobile) {
                if (!mobileHealthContainer) {
                    mobileHealthContainer = document.createElement('div');
                    mobileHealthContainer.id = 'mobile-health-container';
                    document.body.appendChild(mobileHealthContainer);
                }
                if (!mobileHealthContainer.contains(healthDisplay)) {
                    mobileHealthContainer.appendChild(healthDisplay);
                }
            } else {
                if (mobileHealthContainer && mobileHealthContainer.contains(healthDisplay)) {
                    uiOverlay.insertBefore(healthDisplay, uiOverlay.children[1]);
                }
                if (mobileHealthContainer && mobileHealthContainer.parentNode) {
                    mobileHealthContainer.parentNode.removeChild(mobileHealthContainer);
                }
            }
        }
        function addClickSoundToButtons() {
            const buttons = document.querySelectorAll('button');
            buttons.forEach(button => {
                button.addEventListener('click', () => {
                    try {
                        if (loadedAssets.sounds.click) {
                            loadedAssets.sounds.click.play().catch(error => {
                                handleError(new Error('Failed to play click sound'));
                            });
                        }
                    } catch (error) {
                        handleError(error);
                    }
                });
            });
        }
        function loadAssetWithTimeout(loadFunction, timeoutDuration) {
            return new Promise((resolve, reject) => {
                const timeoutId = setTimeout(() => {
                    reject(new Error('Asset loading timed out'));
                }, timeoutDuration);
                loadFunction()
                    .then((result) => {
                        clearTimeout(timeoutId);
                        resolve(result);
                    })
                    .catch((error) => {
                        clearTimeout(timeoutId);
                        reject(error);
                    });
            });
        }
        function loadAssets(callback) {
            let totalAssets = Object.keys(assets.images).length + Object.keys(assets.sounds).length;
            let loadedAssetsCount = 0;
            let errorCount = 0;
            let errors = [];
            const isIphone = /iPhone/i.test(navigator.userAgent);
            function assetLoaded(success, error) {
                if (success) {
                    loadedAssetsCount++;
                } else {
                    errorCount++;
                    errors.push(error);
                }
            }
            const loadImage = (key) => {
                return new Promise((resolve, reject) => {
                    //if (key === 'groundPattern') { reject(new Error(`Failed to load image: ${key}`)); return; } //Simulated error
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = (event) => reject(new Error(`Failed to load image: ${key}`));
                    img.src = assets.images[key];
                });
            };
            const loadSound = (key) => {
                return new Promise((resolve, reject) => {
                    //if (key === 'click') { reject(new Error(`Failed to load image: ${key}`)); return; } //Simulated error
                    const audio = new Audio();
                    audio.addEventListener('canplaythrough', () => resolve(audio), { once: true });
                    audio.addEventListener('error', (event) => reject(new Error(`Failed to load sound: ${key}`)));
                    audio.src = assets.sounds[key];
                });
            };
            const imagePromises = Object.keys(assets.images).map(key =>
                loadAssetWithTimeout(() => loadImage(key), 10000) // 10 seconds timeout
                    .then(img => {
                        loadedAssets.images[key] = img;
                        assetLoaded(true);
                    })
                    .catch(error => assetLoaded(false, error))
            );
            const soundPromises = isIphone ? [] : Object.keys(assets.sounds).map(key =>
                loadAssetWithTimeout(() => loadSound(key), 10000) // 10 seconds timeout
                    .then(audio => {
                        loadedAssets.sounds[key] = audio;
                        assetLoaded(true);
                    })
                    .catch(error => assetLoaded(false, error))
            );
            Promise.all([...imagePromises, ...soundPromises])
                .then(() => {
                    if (errorCount > 0) {
                        console.error(`Failed to load ${errorCount} assets`);
                        showError(new Error(`Failed to load ${errorCount} assets:\n${errors.map(e => e.stack).join('\n')}`));
                    } else {
                        simulateLoading(callback);
                    }
                });
        }
        function simulateLoading(callback) {
            const loadingBar = document.getElementById('loading-progress');
            const loadingPercentage = document.getElementById('loading-percentage');
            let progress = 0;
            const interval = setInterval(() => {
                progress += 1;
                loadingBar.style.width = `${progress}%`;
                loadingPercentage.textContent = `${progress}%`;
                if (progress >= 100) {
                    clearInterval(interval);
                    setTimeout(() => {
                        document.getElementById('loading-screen').style.display = 'none';
                        document.getElementById('game-canvas').style.display = 'block';
                        document.getElementById('ui-overlay').style.display = 'flex';
                        document.getElementById('settings-gear').style.display = 'block';
                        callback();
                    }, 200);
                }
            }, 10);
        }
        const audioPool = {};
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const timeDisplay = document.getElementById('time');
        const scoreDisplay = document.getElementById('score');
        const healthDisplay = document.getElementById('hearts');
        const gameOverScreen = document.getElementById('game-over');
        const introScreen = document.getElementById('intro-screen');
        const settingsScreen = document.getElementById('settings-screen');
        const upgradeScreen = document.getElementById('upgrade-screen');
        const finalScoreDisplay = document.getElementById('final-score');
        const upgradeSummary = document.getElementById('upgrade-summary');
        const restartBtn = document.getElementById('restart-btn');
        const playBtn = document.getElementById('play-btn');
        const settingsGear = document.getElementById('settings-gear');
        const backBtn = document.getElementById('back-btn');
        const uiOverlay = document.getElementById('ui-overlay');
        const highScoreDisplay = document.getElementById('high-score');
        const recordTimeDisplay = document.getElementById('record-time');
        const musicVolumeSlider = document.getElementById('music-volume');
        const sfxVolumeSlider = document.getElementById('sfx-volume');
        const upgradeBtn1 = document.getElementById('upgrade-btn-1');
        const upgradeBtn2 = document.getElementById('upgrade-btn-2');
        const upgradeList = document.getElementById('upgrades-list');
        const cheatUpgrades = document.getElementById('cheat-upgrades');
        const immortalityCheckbox = document.getElementById('immortality');
        const loadingScreen = document.getElementById('loading-screen');
        const prayerCooldownBar = document.getElementById('prayer-cooldown-bar');
        let TOAST_DURATION = 2000;
        let TOAST_ANIMATION_DURATION = 1500;
        let TOAST_VERTICAL_OFFSET = 20;
        let PLAYER_MAX_HEALTH = 5;
        let PLAYER_FIRE_INTERVAL = 400;
        let PICKUP_DROP_RATE = 0.01;
        let PICKUP_HEAL = 0;
        let PICKUP_SCORE_BONUS = 5;
        let PICKUP_UPGRADES = {
            projectiles: { value: 1, multiplier: false, enabled: true, weight: 2 },
            speed: { value: 0.05, multiplier: true, enabled: true, weight: 3 },
            firerate: { value: 0.05, multiplier: true, enabled: true, weight: 1 },
            pierce: { value: 1, multiplier: false, enabled: true, weight: 2 },
            size: { value: 1, multiplier: false, enabled: true, weight: 2 },
            range: { value: 0.05, multiplier: true, enabled: true, weight: 2 },
            prayer: { value: 1, multiplier: false, enabled: false, weight: 1 }
        };
        let BOSS_MAX_HEALTH = 500
        let BOSS_DAMAGE = 2;
        let BOSS_SPEED = 2;
        let BOSS_SCORE_BONUS = 1000;
        let PRAYER_HEAL = 1;
        let PRAYER_BOSS_PUSH_FACTOR = 0.2;
        let PRAYER_BOSS_SPEED_REDUCTION = 0.075;
        let PRAYED = false;
        let RESTED = true;
        let AUTOPRAY = false;
        let autoprayCheckbox;
        let ENEMY_SIZE = 30;
        let ENEMY_DAMAGE = 1;
        let ENEMY_BASE_NUM = 12;
        let ENEMY_SPAWN_QUANTITY = 1;
        let ENEMY_SPAWN_STAGGER_DELAY = 100;
        let ENEMY_SPAWN_OFFSET = 200;
        let ENEMY_SPEED_MULTIPLIER = 1;
        let ENEMY_SPEED_MULTIPLIER_MAX = 2;
        let ENEMY_SPEED_SCALE_FACTOR = 0.3;
        function getPlayerMaxHealth() {
            return PLAYER_MAX_HEALTH;
        }
        let fpsValues;
        let game = {
            player: {
                x: canvas.width / 2,
                y: canvas.height / 2,
                size: 30,
                speed: canvas.width * 0.003,
                direction: null,
                health: getPlayerMaxHealth(),
                invulnerable: false
            },
            lastTime: performance.now(),
            frozenTime: null,
            enemies: [],
            enemySpeedMultiplier: 1,
            bullets: [],
            pickups: [],
            score: 0,
            level: 1,
            gameTime: 0,
            highScore: 0,
            recordTime: 0,
            bossesKilled: 0,
            camera: { x: 0, y: 0, zoom: 0.75 },
            isMouseDown: false,
            targetX: 0,
            targetY: 0,
            lastScoreUpgrade: 0,
            playerUpgrades: {
                projectiles: 1,
                speed: 1,
                firerate: 1,
                pierce: 1,
                size: 1,
                range: 1,
                prayer: 1
            },
            AUTOPRAY: false,
            boss: null,
            prayerCooldown: 0,
            pickupsEaten: 0,
            defaultSpeed: canvas.width * 0.003,
            lastBossSpawnScore: 0,
            prayerActive: false,
            prayerDuration: 0,
            nextEnemySpawnTime: 0,
            fireInterval: null,
            invulnerabilityEndTime: 0,
            remainingInvulnerabilityTime: 0
        };
        const upgradeEmojis = {
            projectiles: '🎯',
            speed: '🏃',
            firerate: '🔥',
            pierce: '🗡️',
            size: '💪',
            range: '🔭',
            prayer: '🙏'
        };
        function updateFPS() {
            const now = performance.now();
            const elapsed = now - lastFrameTime;
            if (!fpsValues) {
                fpsValues = new Array(30).fill(60);
            }
            fpsValues.push(1000 / elapsed);
            fpsValues.shift();
            const averageFPS = Math.round(fpsValues.reduce((sum, value) => sum + value, 0) / fpsValues.length);
            fpsValue = averageFPS;
            lastFrameTime = now;
            if (fpsDisplayEnabled) {
                const fpsMeter = document.getElementById('fps-meter');
                if (fpsMeter) {
                    fpsMeter.textContent = `FPS: ${fpsValue}`;
                }
            }
        }
        function resizeCanvas() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const isTouch = isTouchDevice();
            const touchControlsHeight = isTouch ? 50 : 0;
            const margin = 26; // For shadow space
            const gearHeight = 30; // Height of the settings gear
            const gearMargin = 22; // Bottom margin of the settings gear
            canvas.width = w * 0.98 - margin;
            canvas.height = h - touchControlsHeight - gearHeight - gearMargin - margin * 3;
            uiOverlay.style.width = `${canvas.width}px`;
            uiOverlay.style.left = `${(w - canvas.width) / 2}px`;
            const minFontSize = 12;
            const maxFontSize = 18;
            const fontSize = Math.max(minFontSize, Math.min(maxFontSize, canvas.width * 0.015));
            uiOverlay.style.fontSize = `${fontSize}px`;
            const uiHeight = uiOverlay.offsetHeight;
            canvas.style.marginTop = `${uiHeight - 6}px`; // 2px gap to prevent occlusion
            canvas.style.marginBottom = `${gearHeight + gearMargin + touchControlsHeight + margin}px`;
            canvas.style.marginLeft = 'auto';
            canvas.style.marginRight = 'auto';
            if (isTouch) {
                createTouchControls();
                const touchControls = document.getElementById('touch-controls');
                if (touchControls) {
                    touchControls.style.bottom = '10px';
                }
            }
            if (document.readyState === 'complete') {
                handleMobileLayout();
                updatePrayerBarWidth();
            } else {
                window.addEventListener('load', () => {
                    handleMobileLayout();
                    updatePrayerBarWidth();
                });
            }
        }
        function createTouchControls() {
            if (document.getElementById('touch-controls')) {
                return; // Don't dupe controls
            }
            const controlsContainer = document.createElement('div');
            controlsContainer.id = 'touch-controls';
            controlsContainer.style.position = 'fixed';
            controlsContainer.style.bottom = '0';
            controlsContainer.style.left = '0';
            controlsContainer.style.height = '75px';
            controlsContainer.style.width = '100%';
            controlsContainer.style.display = 'flex';
            controlsContainer.style.justifyContent = 'space-between';
            controlsContainer.style.alignItems = 'center';
            controlsContainer.style.padding = '0 20px';
            controlsContainer.style.boxSizing = 'border-box';
            controlsContainer.style.pointerEvents = 'none';
            controlsContainer.style.transform = 'translateY(-22px)';
            const joystick = document.createElement('div');
            joystick.id = 'joystick';
            joystick.style.width = '80px';
            joystick.style.height = '80px';
            joystick.style.borderRadius = '50%';
            joystick.style.background = 'rgba(255, 255, 255, 0.3)';
            joystick.style.position = 'relative';
            joystick.style.pointerEvents = 'auto';
            const stick = document.createElement('div');
            stick.id = 'stick';
            stick.style.width = '40px';
            stick.style.height = '40px';
            stick.style.borderRadius = '50%';
            stick.style.background = 'rgba(255, 255, 255, 0.5)';
            stick.style.position = 'absolute';
            stick.style.top = '50%';
            stick.style.left = '50%';
            stick.style.transform = 'translate(-50%, -50%)';
            joystick.appendChild(stick);
            const prayerButton = document.createElement('button');
            prayerButton.id = 'prayer-button';
            prayerButton.textContent = '🙏';
            prayerButton.style.width = '80px';
            prayerButton.style.height = '80px';
            prayerButton.style.borderRadius = '50%';
            prayerButton.style.background = 'rgba(255, 255, 255, 0.3)';
            prayerButton.style.border = 'none';
            prayerButton.style.fontSize = '24px';
            prayerButton.style.pointerEvents = 'auto';
            prayerButton.style.position = 'relative';
            prayerButton.style.overflow = 'hidden';
            const prayerInnerCircle = document.createElement('div');
            prayerInnerCircle.id = 'prayer-inner-circle';
            prayerInnerCircle.style.width = '80px';
            prayerInnerCircle.style.height = '80px';
            prayerInnerCircle.style.borderRadius = '50%';
            prayerInnerCircle.style.background = 'rgba(255, 255, 255, 0.5)';
            prayerInnerCircle.style.position = 'absolute';
            prayerInnerCircle.style.top = '50%';
            prayerInnerCircle.style.left = '50%';
            prayerInnerCircle.style.transform = 'translate(-50%, -50%) scale(0)';
            prayerInnerCircle.style.transition = 'transform 0.1s ease-out';
            prayerButton.appendChild(prayerInnerCircle);
            controlsContainer.appendChild(joystick);
            controlsContainer.appendChild(prayerButton);
            document.body.appendChild(controlsContainer);
            if (isTouchDevice()) {
                const joystick = document.getElementById('joystick');
                const stick = document.getElementById('stick');
                const prayerButton = document.getElementById('prayer-button');
                const prayerInnerCircle = document.getElementById('prayer-inner-circle');
                let joystickActive = false;
                let joystickCenter = { x: 0, y: 0 };
                joystick.addEventListener('touchstart', handleJoystickStart);
                joystick.addEventListener('touchmove', handleJoystickMove);
                joystick.addEventListener('touchend', handleJoystickEnd);
                prayerButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    prayer();
                    prayerInnerCircle.style.transform = 'translate(-50%, -50%) scale(1)';
                    PRAYED = true;
                    RESTED = false;
                });
                prayerButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    RESTED = true;
                    prayerInnerCircle.style.transform = 'translate(-50%, -50%) scale(0)';
                });
                function handleJoystickStart(e) {
                    e.preventDefault();
                    joystickActive = true;
                    const joystickRect = joystick.getBoundingClientRect();
                    joystickCenter = {
                        x: joystickRect.left + joystickRect.width / 2,
                        y: joystickRect.top + joystickRect.height / 2
                    };
                }
                function handleJoystickMove(e) {
                    if (!joystickActive) return;
                    const touch = e.touches[0];
                    const dx = touch.clientX - joystickCenter.x;
                    const dy = touch.clientY - joystickCenter.y;
                    const distance = Math.min(40, Math.sqrt(dx * dx + dy * dy));
                    const angle = Math.atan2(dy, dx);
                    const x = Math.cos(angle) * distance;
                    const y = Math.sin(angle) * distance;
                    stick.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
                    game.joystickInput = { x: x / 40, y: y / 40 };
                    game.player.direction = angle;
                }
                function handleJoystickEnd(e) {
                    joystickActive = false;
                    stick.style.transform = 'translate(-50%, -50%)';
                    game.joystickInput = null;
                }
            }
        }
        let heartElements = [];
        function updateHealthDisplay() {
            if (heartElements.length !== getPlayerMaxHealth()) {
                healthDisplay.innerHTML = '';
                for (let i = 0; i < getPlayerMaxHealth(); i++) {
                    const h = document.createElement('span');
                    h.style.width = '20px';
                    h.style.display = 'inline-block';
                    healthDisplay.appendChild(h);
                    heartElements.push(h);
                }
            }
            heartElements.forEach((h, i) => {
                h.className = i < game.player.health ? 'heart' : 'heart heart-empty';
            });
            updatePrayerBarWidth();
        }
        function updatePrayerBarWidth() {
            const hearts = document.getElementById('hearts');
            const prayerCooldown = document.getElementById('prayer-cooldown');
            const heartsRect = hearts.getBoundingClientRect();
            prayerCooldown.style.width = `${heartsRect.width}px`;
            prayerCooldown.style.marginLeft = `${hearts.offsetLeft - prayerCooldown.offsetLeft}px`;
        }
        function updatePrayerCooldown() {
            if (game.prayerCooldown > 0) {
                game.prayerCooldown -= 1 / 60; // Assuming 60 FPS
            }
            const p = (300 - game.prayerCooldown * 60) / 300 * 100;
            prayerCooldownBar.style.width = `${p}%`;
            prayerCooldownBar.style.background = game.playerUpgrades.prayer > 0 ? '#4169e1' : '#444';
        }
        function drawGround() {
            const p = ctx.createPattern(loadedAssets.images.groundPattern, 'repeat');
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(game.camera.zoom, game.camera.zoom);
            ctx.translate(-game.player.x, -game.player.y);
            ctx.fillStyle = p;
            const s = 0.5;
            ctx.scale(s, s);
            ctx.fillRect(
                (game.player.x - canvas.width / (2 * game.camera.zoom)) / s,
                (game.player.y - canvas.height / (2 * game.camera.zoom)) / s,
                (canvas.width / game.camera.zoom) / s,
                (canvas.height / game.camera.zoom) / s
            );
            ctx.restore();
        }
        function drawPlayer() {
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(game.camera.zoom, game.camera.zoom);
            ctx.translate(-game.player.x, -game.player.y);
            ctx.translate(game.player.x, game.player.y);
            ctx.rotate(game.player.direction + Math.PI / 2);
            if (game.player.invulnerable || immortalityCheckbox.checked) {
                ctx.globalAlpha = 0.5 + Math.sin(performance.now() / 100) * 0.5;
            }
            ctx.shadowBlur = 40 + game.playerUpgrades.prayer * 5;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.fillStyle = '#a9a9a9';
            ctx.beginPath();
            ctx.arc(0, 0, game.player.size / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#8B0000';
            ctx.beginPath();
            ctx.moveTo(-game.player.size / 4, game.player.size / 2);
            ctx.lineTo(game.player.size / 4, game.player.size / 2);
            ctx.lineTo(game.player.size / 3, game.player.size * 0.75);
            ctx.lineTo(-game.player.size / 3, game.player.size * 0.75);
            ctx.closePath();
            ctx.fill();
            ctx.save();
            ctx.rotate(Math.PI / 6);
            ctx.fillStyle = '#4682B4';
            ctx.beginPath();
            ctx.moveTo(-game.player.size * 0.9, -game.player.size / 2);
            ctx.lineTo(-game.player.size * 0.9, game.player.size / 2);
            ctx.lineTo(-game.player.size / 2, game.player.size / 4);
            ctx.lineTo(-game.player.size / 2, -game.player.size / 4);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-game.player.size * 0.75, -game.player.size / 4);
            ctx.lineTo(-game.player.size * 0.75, game.player.size / 4);
            ctx.moveTo(-game.player.size * 0.9, 0);
            ctx.lineTo(-game.player.size * 0.6, 0);
            ctx.stroke();
            ctx.restore();
            ctx.fillStyle = '#505050';
            ctx.beginPath();
            ctx.moveTo(-game.player.size / 2, -game.player.size / 2);
            ctx.lineTo(game.player.size / 2, -game.player.size / 2);
            ctx.lineTo(game.player.size / 4, 0);
            ctx.lineTo(-game.player.size / 4, 0);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#a9a9a9';
            ctx.beginPath();
            ctx.moveTo(-game.player.size / 4, -game.player.size / 2 + 2);
            ctx.lineTo(game.player.size / 4, -game.player.size / 2 + 2);
            ctx.lineTo(game.player.size / 4, 0);
            ctx.lineTo(-game.player.size / 4, 0);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(game.player.size / 2, -game.player.size / 4);
            ctx.lineTo(game.player.size / 2 + 12, -game.player.size / 4 - 12);
            ctx.stroke();
            ctx.restore();
        }
        function drawEnemies() {
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(game.camera.zoom, game.camera.zoom);
            ctx.translate(-game.player.x, -game.player.y);
            game.enemies.forEach(e => {
                ctx.fillStyle = '#800000';
                ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
                ctx.beginPath();
                ctx.moveTo(e.x - e.size / 2, e.y - e.size / 2);
                ctx.lineTo(e.x, e.y + e.size / 2);
                ctx.lineTo(e.x + e.size / 2, e.y - e.size / 2);
                ctx.fillStyle = '#000000';
                ctx.fill();
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(e.x, e.y - e.size / 4, e.size / 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.arc(e.x - e.size / 8, e.y - e.size / 4, e.size / 16, 0, Math.PI * 2);
                ctx.arc(e.x + e.size / 8, e.y - e.size / 4, e.size / 16, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();
        }
        function drawBoss() {
            if (!game.boss) return;
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(game.camera.zoom, game.camera.zoom);
            ctx.translate(-game.player.x, -game.player.y);
            ctx.fillStyle = '#00FF00';
            ctx.fillRect(game.boss.x - game.boss.size / 2, game.boss.y - game.boss.size / 2, game.boss.size, game.boss.size);
            ctx.beginPath();
            ctx.moveTo(game.boss.x - game.boss.size / 2, game.boss.y - game.boss.size / 2);
            ctx.lineTo(game.boss.x, game.boss.y + game.boss.size / 2);
            ctx.lineTo(game.boss.x + game.boss.size / 2, game.boss.y - game.boss.size / 2);
            ctx.fillStyle = '#004400';
            ctx.fill();
            ctx.fillStyle = '#8FFF00';
            ctx.beginPath();
            ctx.arc(game.boss.x, game.boss.y - game.boss.size / 4, game.boss.size / 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.arc(game.boss.x - game.boss.size / 8, game.boss.y - game.boss.size / 4, game.boss.size / 16, 0, Math.PI * 2);
            ctx.arc(game.boss.x + game.boss.size / 8, game.boss.y - game.boss.size / 4, game.boss.size / 16, 0, Math.PI * 2);
            ctx.fill();
            const w = game.boss.size * 1.5;
            const h = 10;
            const p = Math.max(game.boss.health / BOSS_MAX_HEALTH, 0);
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(game.boss.x - w / 2, game.boss.y - game.boss.size / 2 - 20, w, h);
            ctx.fillStyle = '#00FF00';
            ctx.fillRect(game.boss.x - w / 2, game.boss.y - game.boss.size / 2 - 20, w * p, h);
            ctx.restore();
        }
        function drawBullets() {
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(game.camera.zoom, game.camera.zoom);
            ctx.translate(-game.player.x, -game.player.y);
            ctx.fillStyle = '#ffff00';
            game.bullets.forEach(b => {
                const s = 10;
                const c = s + b.size + game.playerUpgrades.size;
                const w = c * 0.3;
                const h = c * 0.7;
                ctx.save();
                ctx.translate(b.x, b.y);
                ctx.rotate(Math.atan2(b.dy, b.dx));
                ctx.fillRect(-w / 2, -h / 2, w, h);
                ctx.fillRect(-c / 2, -w / 2, c, w);
                ctx.restore();
            });
            ctx.restore();
        }
        function drawPickups() {
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(game.camera.zoom, game.camera.zoom);
            ctx.translate(-game.player.x, -game.player.y);
            game.pickups.forEach(item => {
                ctx.save();
                ctx.translate(item.x, item.y);
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'rgba(255, 255, 255, 0.7)';
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.fillStyle = '#F4E6CC';
                ctx.beginPath();
                ctx.arc(0, 0, item.size / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#8B4513';
                const crossSize = item.size * 0.7;
                const crossThickness = item.size * 0.08; // Reduced thickness
                ctx.fillRect(-crossThickness / 2, -crossSize / 2, crossThickness, crossSize);
                ctx.fillRect(-crossSize / 2, -crossThickness / 2, crossSize, crossThickness);
                ctx.restore();
            });
            ctx.restore();
        }
        function updatePickups() {
            game.pickups = game.pickups.filter(i => {
                const dx = game.player.x - i.x;
                const dy = game.player.y - i.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < game.player.size / 2 + i.size) {
                    game.player.health = Math.min(game.player.health + PICKUP_HEAL, getPlayerMaxHealth());
                    updateHealthDisplay();
                    playSound('pickup', 1, 0);
                    game.pickupsEaten++;
                    game.score += PICKUP_SCORE_BONUS;
                    scoreDisplay.textContent = game.score;
                    let toastMessage = [];
                    if (PICKUP_HEAL > 0) {
                        toastMessage.push(`❤️ +${PICKUP_HEAL}`);
                    }
                    if (toastMessage.length > 0) {
                        showToast(toastMessage.join(' '), i.x, i.y, 'updatePickups');
                    }
                    applyPickupUpgrades(i.x, i.y);
                    return false;
                }
                return true;
            });
        }
        function applyPickupUpgrades(x, y) {
            const enabledUpgrades = Object.entries(PICKUP_UPGRADES)
                .filter(([_, config]) => config.enabled)
                .reduce((acc, [key, config]) => {
                    for (let i = 0; i < config.weight; i++) {
                        acc.push(key);
                    }
                    return acc;
                }, []);
            if (enabledUpgrades.length > 0) {
                const appliedUpgrades = [];
                for (let i = 0; i < 1; i++) {  // Apply up to 1 upgrade per pickup
                    if (enabledUpgrades.length > 0) {
                        const randomIndex = Math.floor(Math.random() * enabledUpgrades.length);
                        const upgrade = enabledUpgrades.splice(randomIndex, 1)[0];
                        applyUpgrade(upgrade, false); // Pass false to prevent toast creation
                        appliedUpgrades.push(upgrade);
                    }
                }
                if (appliedUpgrades.length > 0) {
                    const upgradeMessage = appliedUpgrades.map(upgrade => {
                        const config = PICKUP_UPGRADES[upgrade];
                        let value = config.value;
                        if (config.multiplier) {
                            value = (value * 100).toFixed(0) + '%';
                        }
                        return `${upgradeEmojis[upgrade]} +${value}`;
                    }).join(' ');
                    showToast(upgradeMessage, x, y, 'applyPickupUpgrades');
                }
            }
        }
        function handleCollisions() {
            if (currentState !== GameState.PLAYING || game.boss) return;
            const hitEnemies = new Set();
            const playerHitbox = game.player.size / 2;
            game.enemies = game.enemies.filter(enemy => {
                const dx = game.player.x - enemy.x;
                const dy = game.player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < playerHitbox + enemy.size / 2) {
                    handlePlayerHit(enemy.damage);
                }
                let hit = false;
                game.bullets = game.bullets.filter(b => {
                    if (hitEnemies.has(enemy)) return b.lifetime > 0 && b.pierceCount > 0;
                    const dx = enemy.x - b.x;
                    const dy = enemy.y - b.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < enemy.size / 2 + b.size + game.playerUpgrades.size) {
                        hit = true;
                        hitEnemies.add(enemy);
                        b.pierceCount--;
                        handleEnemyHit(enemy);
                        return b.lifetime > 0 && b.pierceCount > 0;
                    }
                    return b.lifetime > 0 && b.pierceCount > 0;
                });
                return !hit;
            });
        }
        function updateGame() {
            const now = performance.now();
            let deltaTime = (now - lastTime) / 1000;
            lastTime = now;
            if (currentState === GameState.PLAYING || currentState === GameState.INTRO || currentState === GameState.GAME_OVER) {
                game.gameTime += deltaTime;
            }
            updateTime();
            clearCanvas();
            drawObjects(deltaTime);
            updateObjects(deltaTime);
            handleCollisions();
            updateFPS();
            if (currentState !== GameState.PAUSED && currentState !== GameState.UPGRADING && game.player.invulnerable && performance.now() >= game.invulnerabilityEndTime) {
                game.player.invulnerable = false;
            }
            animationFrameId = requestAnimationFrame(updateGame);
        }
        function updateTime() {
            if (currentState === GameState.PLAYING) {
                const totalGameTime = Math.floor(game.gameTime);
                const minutes = Math.floor(totalGameTime / 60);
                const seconds = totalGameTime % 60;
                timeDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        function drawObjects(deltaTime) {
            drawGround();
            if (currentState === GameState.INTRO || currentState === GameState.GAME_OVER) {
                updateBloodDrops();
                drawBloodDrops();
                if (currentState === GameState.INTRO) {
                    timeDisplay.textContent = '00:00';
                    updateEnemies(deltaTime);
                    drawEnemies();
                }
            }
            drawPlayer();
            drawBullets();
            if (game.boss) {
                drawBoss();
                updateBoss(deltaTime);
            } else {
                drawEnemies();
                updateEnemies(deltaTime);
                if (currentState === GameState.PLAYING || currentState === GameState.INTRO || currentState === GameState.GAME_OVER) {
                    if (game.gameTime >= game.nextEnemySpawnTime) {
                        spawnEnemies();
                        game.nextEnemySpawnTime = game.gameTime + Math.random() * 2.5 + 0.5;
                    }
                    if (game.score - game.lastBossSpawnScore >= 1000) {
                        spawnBoss();
                        game.lastBossSpawnScore = game.score;
                    }
                }
            }
            drawPickups();
            if (currentState === GameState.PLAYING) {
                if (game.bossesKilled > 0) {
                    updateGodRays(deltaTime);
                    drawGodRays();
                }
            }
        }
        function updateObjects(deltaTime) {
            if (currentState === GameState.PLAYING) {
                if (isTouchDevice() && game.isMoving) {
                    updatePlayerPosition(deltaTime);
                } else {
                    updatePlayerPosition(deltaTime);
                }
                updateBullets(deltaTime);
                updatePickups();
                updatePrayerCooldown();
            }
        }
        function updatePlayerPosition(deltaTime) {
            if (game.joystickInput) {
                const moveSpeed = game.player.speed * game.playerUpgrades.speed;
                game.player.x += game.joystickInput.x * moveSpeed * deltaTime * 60;
                game.player.y += game.joystickInput.y * moveSpeed * deltaTime * 60;
                game.player.direction = Math.atan2(game.joystickInput.y, game.joystickInput.x);
            } else if (game.isMoving && game.player.direction !== null) {
                const moveSpeed = game.player.speed * game.playerUpgrades.speed;
                game.player.x += Math.cos(game.player.direction) * moveSpeed * deltaTime * 60;
                game.player.y += Math.sin(game.player.direction) * moveSpeed * deltaTime * 60;
            }
        }
        function updateBullets(deltaTime) {
            game.bullets.forEach(b => {
                b.x += b.dx * b.speed * deltaTime * 60;
                b.y += b.dy * b.speed * deltaTime * 60;
                b.lifetime -= deltaTime;
            });
        }
        function handleEnemyHit(enemy) {
            game.score++;
            scoreDisplay.textContent = game.score;
            playSound('enemyDeath', 1, 0.02);
            if (Math.random() < PICKUP_DROP_RATE / Math.pow(2, game.bossesKilled)) {
                game.pickups.push({ x: enemy.x, y: enemy.y, size: ENEMY_SIZE });
                playSound('pickupDrop', 0.8, 0.8);
            }
            if (game.score % (50 * Math.pow(2, game.bossesKilled)) === 0 && game.score !== game.lastScoreUpgrade) {
                game.lastScoreUpgrade = game.score;
                showUpgradeScreen();
            }
        }
        function updateEnemies(deltaTime) {
            if (game.boss || (currentState !== GameState.PLAYING && currentState !== GameState.INTRO && currentState !== GameState.GAME_OVER)) return;
            const factor = game.prayerActive && currentState === GameState.PLAYING
                ? -0.1 * Math.min(game.playerUpgrades.prayer, 10)
                : 1;
            const speedMultiplier = Math.min(
                1 + Math.log(game.score + 1) * ENEMY_SPEED_SCALE_FACTOR,
                ENEMY_SPEED_MULTIPLIER_MAX
            );
            const mobileSpeedBoost = isMobile ? 0.5 : 1; // Add this line
            game.enemies.forEach(enemy => {
                const dx = game.player.x - enemy.x;
                const dy = game.player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                enemy.x += dx / distance * enemy.speed * factor * speedMultiplier * mobileSpeedBoost * deltaTime * 60; // Modify this line
                enemy.y += dy / distance * enemy.speed * factor * speedMultiplier * mobileSpeedBoost * deltaTime * 60; // Modify this line
            });
            if ((currentState === GameState.GAME_OVER || currentState === GameState.INTRO) && game.enemies.length > 200) {
                game.enemies.shift();
            }
        }
        function handlePlayerHit(damage = 1) {
            if (game.player.invulnerable || immortalityCheckbox.checked) return;
            game.player.health -= damage;
            updateHealthDisplay();
            document.body.classList.add('hurt');
            let pulseTimeout = setTimeout(() => document.body.classList.remove('hurt'), 500);
            if (game.player.health <= 0) {
                playSound('death', 1, 0);
                gameOver();
            } else {
                playSound('hurt', 1, 0);
            }
            game.player.invulnerable = true;
            game.invulnerabilityEndTime = performance.now() + 1000; // 1 second of invulnerability
            const checkMenuInterval = setInterval(() => {
                const isMenuOpen = settingsScreen.style.display === 'block' ||
                    upgradeScreen.style.display === 'block' ||
                    gameOverScreen.style.display === 'block' ||
                    introScreen.style.display === 'block';
                if (isMenuOpen) {
                    clearTimeout(pulseTimeout);
                } else {
                    clearInterval(checkMenuInterval);
                    pulseTimeout = setTimeout(() => document.body.classList.remove('hurt'), 500);
                }
            }, 100);
        }
        function spawnEnemies() {
            if (game.boss) return;
            const scoreProgress = Math.min(game.score / 1000, 1);
            const densityMultiplier = 1 + scoreProgress;
            const numEnemies = Math.floor(ENEMY_BASE_NUM * ENEMY_SPAWN_QUANTITY * densityMultiplier);
            const distance = Math.max(canvas.width, canvas.height) / (2 * game.camera.zoom) + ENEMY_SPAWN_OFFSET;
            for (let i = 0; i < numEnemies; i++) {
                setTimeout(() => {
                    const angle = Math.random() * Math.PI * 2;
                    const x = game.player.x + Math.cos(angle) * distance;
                    const y = game.player.y + Math.sin(angle) * distance;
                    const baseSpeed = canvas.width * 0.000625 * ENEMY_SPEED_MULTIPLIER;
                    game.enemySpeedMultiplier = Math.min(
                        1 + Math.log(game.score + 1) * ENEMY_SPEED_SCALE_FACTOR,
                        ENEMY_SPEED_MULTIPLIER_MAX
                    );
                    const enemySpeed = baseSpeed * game.enemySpeedMultiplier * (isMobile ? 2 : 1);
                    const [enemySize, enemyDamage] = game.bossesKilled > 0 ? [60, 2] : [ENEMY_SIZE, ENEMY_DAMAGE];
                    game.enemies.push({
                        x,
                        y,
                        size: enemySize,
                        speed: enemySpeed,
                        damage: enemyDamage
                    });
                }, i * ENEMY_SPAWN_STAGGER_DELAY);
            }
        }
        function spawnBoss() {
            const side = Math.floor(Math.random() * 4);
            let x, y;
            const distance = Math.max(canvas.width, canvas.height) / (2 * game.camera.zoom);
            switch (side) {
                case 0: x = game.player.x + (Math.random() - 0.5) * distance * 2; y = game.player.y - distance; break;
                case 1: x = game.player.x + distance; y = game.player.y + (Math.random() - 0.5) * distance * 2; break;
                case 2: x = game.player.x + (Math.random() - 0.5) * distance * 2; y = game.player.y + distance; break;
                case 3: x = game.player.x - distance; y = game.player.y + (Math.random() - 0.5) * distance * 2; break;
            }
            game.boss = {
                x,
                y,
                size: 60,
                speed: game.player.speed * BOSS_SPEED,
                health: BOSS_MAX_HEALTH,
                damage: BOSS_DAMAGE + game.bossesKilled
            };
            game.enemies = [];
            playSound('bossSpawn', 1, 0);
            playMusic('bossMusic');
            game.player.speed = game.defaultSpeed;
            game.playerUpgrades.speed = 1;
            updateUpgradesList();
        }
        function shoot() {
            if (currentState !== GameState.PLAYING) return;
            const nearestEnemy = findNearestEnemy();
            if (nearestEnemy) {
                for (let i = 0; i < game.playerUpgrades.projectiles; i++) {
                    const spreadFactor = game.playerUpgrades.projectiles * 1;
                    const angle = Math.atan2(nearestEnemy.y - game.player.y, nearestEnemy.x - game.player.x) + (Math.random() - 0.5) * 0.2 * spreadFactor;
                    const dx = Math.cos(angle);
                    const dy = Math.sin(angle);
                    game.bullets.push({
                        x: game.player.x,
                        y: game.player.y,
                        dx,
                        dy,
                        size: canvas.width * 0.005,
                        speed: canvas.width * 0.01,
                        lifetime: 0.4 * game.playerUpgrades.range,
                        pierceCount: game.playerUpgrades.pierce
                    });
                }
            }
            playSound('bulletFire', 1, 0.1);
        }
        function findNearestEnemy() {
            let nearest = game.enemies.reduce((nearest, e) => {
                const dx = e.x - game.player.x;
                const dy = e.y - game.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < nearest.distance ? { enemy: e, distance } : nearest;
            }, { enemy: null, distance: Infinity });
            if (game.boss) {
                const dx = game.boss.x - game.player.x;
                const dy = game.boss.y - game.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < nearest.distance) {
                    nearest = { enemy: game.boss, distance };
                }
            }
            return nearest.enemy;
        }
        function prayer() {
            if (currentState === GameState.PLAYING && game.playerUpgrades.prayer >= 0 && game.prayerCooldown <= 0) {
                if (RESTED || AUTOPRAY) {
                    const range = canvas.width * 0.2 * (1 + (game.playerUpgrades.prayer - 1) * 0.1);
                    let hits = 0;
                    if (!game.boss) {
                        game.enemies = game.enemies.filter(e => {
                            const dx = e.x - game.player.x;
                            const dy = e.y - game.player.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance <= range && hits < game.playerUpgrades.prayer) {
                                hits++;
                                game.score++;
                                scoreDisplay.textContent = game.score;
                                playSound('enemyDeath', 1, 0.02);
                                return false;
                            }
                            return true;
                        });
                        updatePrayerCooldown();
                    }
                    game.player.health = Math.min(game.player.health + PRAYER_HEAL, getPlayerMaxHealth());
                    updateHealthDisplay();
                    playSound('prayer', 1, 0);
                    game.prayerCooldown = 5;
                    game.prayerActive = true;
                    game.prayerDuration = 1;
                    showToast(`+${PRAYER_HEAL}❤️`, game.player.x, game.player.y, 'prayer');
                    const prayerInterval = setInterval(() => {
                        if (game.prayerDuration > 0) {
                            game.prayerDuration--;
                        } else {
                            game.prayerActive = false;
                            clearInterval(prayerInterval);
                        }
                    }, 1000);
                    updatePrayerCooldown();
                }
            }
        }
        function gameOver() {
            currentState = GameState.GAME_OVER;
            gameOverScreen.style.display = 'block';
            finalScoreDisplay.textContent = game.score;
            settingsScreen.style.display = 'none';
            upgradeScreen.style.display = 'none';
            game.enemySpeedMultiplier = 1;
            loadedAssets.images.groundPattern = originalGroundPattern;
            if (loadedAssets.sounds.currentBgMusic) {
                loadedAssets.sounds.currentBgMusic.pause();
                loadedAssets.sounds.currentBgMusic.currentTime = 0;
            }
            setTimeout(() => {
                playMusic('bgMusic')
                    .catch(error => console.error('Failed to play background music:', error));
            }, 100);
            if (game.score > game.highScore) {
                game.highScore = game.score;
                highScoreDisplay.textContent = game.highScore;
            }
            if (game.gameTime > game.recordTime) {
                game.recordTime = game.gameTime;
                const recordMinutes = Math.floor(game.recordTime / 60);
                const recordSeconds = Math.floor(game.recordTime % 60);
                recordTimeDisplay.textContent = `${recordMinutes.toString().padStart(2, '0')}:${recordSeconds.toString().padStart(2, '0')}`;
            }
            upgradeSummary.innerHTML = `
        <h3>Upgrades Acquired</h3>
        <ul id="upgrades-list">
            <li>${upgradeEmojis.projectiles} Projectiles: ${game.playerUpgrades.projectiles}</li>
            <li>${upgradeEmojis.speed} Speed: ${(game.playerUpgrades.speed * 100 - 100).toFixed(0)}%</li>
            <li>${upgradeEmojis.firerate} Fire Rate: ${(game.playerUpgrades.firerate * 100 - 100).toFixed(0)}%</li>
            <li>${upgradeEmojis.pierce} Pierce: ${game.playerUpgrades.pierce}</li>
            <li>${upgradeEmojis.size} Projectile Size: ${game.playerUpgrades.size}</li>
            <li>${upgradeEmojis.range} Range: ${(game.playerUpgrades.range * 100 - 100).toFixed(0)}%</li>
            <li>${upgradeEmojis.prayer} Prayer: ${game.playerUpgrades.prayer}</li>
            <li>🍗 Pickups: ${game.pickupsEaten}</li>
            <li>👾 Bosses Killed: ${game.bossesKilled}</li>
        </ul>
    `;
            game.nextEnemySpawnTime = 0;
        }
        function startGame() {
            try {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                const highScore = game.highScore;
                const recordTime = game.recordTime;
                if (game.fireInterval) {
                    clearInterval(game.fireInterval);
                }
                game = {
                    player: {
                        x: canvas.width / 2,
                        y: canvas.height / 2,
                        size: 30,
                        speed: canvas.width * 0.003,
                        direction: null,
                        health: getPlayerMaxHealth(),
                        invulnerable: false
                    },
                    frozenTime: null,
                    enemies: [],
                    enemySpeedMultiplier: 1,
                    bullets: [],
                    pickups: [],
                    score: 0,
                    level: 1,
                    gameTime: 0,
                    highScore: highScore,
                    recordTime: recordTime,
                    bossesKilled: 0,
                    camera: { x: 0, y: 0, zoom: 0.75 },
                    isMouseDown: false,
                    targetX: 0,
                    targetY: 0,
                    lastScoreUpgrade: 0,
                    playerUpgrades: {
                        projectiles: 1,
                        speed: 1,
                        firerate: 1,
                        pierce: 1,
                        size: 1,
                        range: 1,
                        prayer: 1
                    },
                    boss: null,
                    prayerCooldown: 0,
                    prayerIssued: false,
                    pickupsEaten: 0,
                    defaultSpeed: canvas.width * 0.003,
                    lastBossSpawnScore: 0,
                    prayerActive: false,
                    prayerDuration: 0,
                    nextEnemySpawnTime: 0,
                    fireInterval: null,
                    joystickInput: null,
                };
                lastTime = performance.now();
                currentState = GameState.PLAYING;
                introScreen.style.display = 'none';
                gameOverScreen.style.display = 'none';
                upgradeScreen.style.display = 'none';
                settingsGear.style.display = 'none';
                scoreDisplay.textContent = '0';
                timeDisplay.textContent = '00:00';
                updateHealthDisplay();
                updatePrayerCooldown();
                updateUpgradesList();
                resizeCanvas();
                game.fireInterval = setInterval(() => {
                    if (currentState === GameState.PLAYING) {
                        shoot();
                    }
                }, PLAYER_FIRE_INTERVAL / game.playerUpgrades.firerate);
                animationFrameId = requestAnimationFrame(updateGame);
            }
            catch (error) {
                showError(error);
            }
        }
        function restartGame() {
            currentState = GameState.INTRO;
            introScreen.style.display = 'block';
            gameOverScreen.style.display = 'none';
            resetCheats();
        }
        function resetCheats() {
            const immortalityCheckbox = document.getElementById('immortality');
            const autoprayCheckbox = document.getElementById('autopray');
            const healthSlider = document.getElementById('health');
            if (immortalityCheckbox) {
                immortalityCheckbox.checked = false;
            } else {
                console.error('Element with id "immortality" not found');
            }
            if (autoprayCheckbox) {
                autoprayCheckbox.checked = false;
            } else {
                console.error('Element with id "autopray" not found');
            }
            if (healthSlider) {
                healthSlider.value = healthSlider.max;
                game.player.health = parseInt(healthSlider.max);
                updateHealthDisplay();
            } else {
                console.error('Element with id "health" not found');
            }
            document.body.classList.remove('yellow-text');
        }
        function spawnBossCheat() {
            if (!game.boss) {
                spawnBoss();
            }
        }
        function showUpgradeScreen() {
            currentState = GameState.UPGRADING;
            upgradeScreen.style.display = 'block';
            const upgrades = ['projectiles', 'speed', 'firerate', 'pierce', 'size', 'range', 'prayer'];
            const selectedUpgrades = upgrades.sort(() => 0.5 - Math.random()).slice(0, 2);
            upgradeBtn1.textContent = `${upgradeEmojis[selectedUpgrades[0]]} ${getUpgradeText(selectedUpgrades[0])}`;
            upgradeBtn2.textContent = `${upgradeEmojis[selectedUpgrades[1]]} ${getUpgradeText(selectedUpgrades[1])}`;
            upgradeBtn1.onclick = () => applyUpgrade(selectedUpgrades[0]);
            upgradeBtn2.onclick = () => applyUpgrade(selectedUpgrades[1]);
            upgradeBtn1.classList.remove('blue-button');
            upgradeBtn2.classList.remove('blue-button');
            if (selectedUpgrades[0] === 'prayer') {
                upgradeBtn1.classList.add('blue-button');
            }
            if (selectedUpgrades[1] === 'prayer') {
                upgradeBtn2.classList.add('blue-button');
            }
            playSound('upgrade');
            if (game.player.invulnerable) {
                document.body.classList.add('hurt');
                game.remainingInvulnerabilityTime = game.invulnerabilityEndTime - performance.now();
            }
        }
        function hideUpgradeScreen() {
            upgradeScreen.style.display = 'none';
            currentState = GameState.PLAYING;
            if (game.player.invulnerable) {
                document.body.classList.add('hurt');
                game.invulnerabilityEndTime = performance.now() + game.remainingInvulnerabilityTime;
            }
        }
        function getUpgradeText(upgrade) {
            const config = PICKUP_UPGRADES[upgrade];
            let value = config.value;
            if (config.multiplier) {
                value = (value * 100).toFixed(0) + '%';
            }
            switch (upgrade) {
                case 'projectiles': return `+${value} Projectile`;
                case 'speed': return `+${value} Movement Speed`;
                case 'firerate': return `+${value} Fire Rate`;
                case 'pierce': return `+${value} Pierce`;
                case 'size': return `+${value} Projectile Size`;
                case 'range': return `+${value} Projectile Range`;
                case 'prayer': return `+${value} Prayer`;
            }
        }
        function applyUpgrade(upgrade, showToastMessage = true) {
            const upgradeConfig = PICKUP_UPGRADES[upgrade];
            let upgradeValue = upgradeConfig.value;
            if (upgradeConfig.multiplier) {
                game.playerUpgrades[upgrade] *= (1 + upgradeValue);
                upgradeValue = `${(upgradeValue * 100).toFixed(0)}%`;
            } else {
                game.playerUpgrades[upgrade] += upgradeValue;
            }
            if (upgrade === 'firerate') {
                clearInterval(game.fireInterval);
                game.fireInterval = setInterval(() => {
                    if (currentState === GameState.PLAYING) {
                        shoot();
                    }
                }, PLAYER_FIRE_INTERVAL / game.playerUpgrades.firerate);
            }
            if (showToastMessage) {
                showToast(`${upgradeEmojis[upgrade]} +${upgradeValue}`, game.player.x, game.player.y, 'applyUpgrade');
            }
            updateUpgradesList();
            if (currentState === GameState.UPGRADING) {
                hideUpgradeScreen();
            }
        }
        function updateUpgradesList() {
            upgradeList.innerHTML = '';
            for (const [key, value] of Object.entries(game.playerUpgrades)) {
                const listItem = document.createElement('li');
                listItem.textContent = `${upgradeEmojis[key]} ${key}: ${value}`;
                upgradeList.appendChild(listItem);
            }
        }
        function showToast(message, x, y, callingFunction) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            const rect = canvas.getBoundingClientRect();
            let toastX, toastY;
            if (x !== undefined && y !== undefined) {
                toastX = rect.left + ((x - game.player.x) * game.camera.zoom + canvas.width / 2);
                toastY = rect.top + ((y - game.player.y) * game.camera.zoom + canvas.height / 2);
            } else {
                toastX = rect.left + canvas.width / 2;
                toastY = rect.top + canvas.height / 2;
            }
            toast.style.left = `${toastX - toast.offsetWidth / 2}px`;
            toast.style.top = `${toastY - toast.offsetHeight - TOAST_VERTICAL_OFFSET}px`;
            setTimeout(() => {
                toast.classList.add('float-up');
                setTimeout(() => toast.remove(), TOAST_ANIMATION_DURATION);
            }, 200);
        }
        function updateBoss(deltaTime) {
            if (!game.boss) return;
            if (currentState !== GameState.PAUSED && currentState !== GameState.INTRO) {
                const dx = game.player.x - game.boss.x;
                const dy = game.player.y - game.boss.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                let speed = game.boss.speed * (isMobile ? 2 : 1); // Modify this line
                if (game.prayerActive) {
                    const prayerEffect = Math.min(game.playerUpgrades.prayer, 10);
                    speed *= (1 - PRAYER_BOSS_SPEED_REDUCTION * prayerEffect);
                    game.boss.x -= (dx / distance) * speed * PRAYER_BOSS_PUSH_FACTOR * prayerEffect * deltaTime * 60; // Add deltaTime * 60
                    game.boss.y -= (dy / distance) * speed * PRAYER_BOSS_PUSH_FACTOR * prayerEffect * deltaTime * 60; // Add deltaTime * 60
                } else {
                    game.boss.x += (dx / distance) * speed * deltaTime * 60; // Add deltaTime * 60
                    game.boss.y += (dy / distance) * speed * deltaTime * 60; // Add deltaTime * 60
                }
                game.bullets = game.bullets.filter(b => {
                    const bx = game.boss.x - b.x;
                    const by = game.boss.y - b.y;
                    const bulletDistance = Math.sqrt(bx * bx + by * by);
                    if (bulletDistance < game.boss.size / 2 + b.size + game.playerUpgrades.size) {
                        b.pierceCount--;
                        game.boss.health--;
                        return b.lifetime > 0 && b.pierceCount > 0;
                    }
                    return true;
                });
                if (distance < game.player.size / 2 + game.boss.size / 2 && !game.player.invulnerable && !immortalityCheckbox.checked) {
                    handlePlayerHit(game.boss.damage);
                }
            }
            if (game.boss.health <= 0) {
                game.score += BOSS_SCORE_BONUS; // Changed from BOSS_SCORE_PRIZE to BOSS_SCORE_BONUS
                scoreDisplay.textContent = game.score;
                playSound('bossDeath', 1, 0);
                game.boss = null;
                game.bossesKilled++;
                game.enemies = [];
                spawnEnemies();
                game.lastBossSpawnScore = game.score; // Reset the last boss spawn score
                if (game.bossesKilled >= 1) {
                    loadedAssets.images.groundPattern = loadedAssets.images.victoryPattern;
                    drawGround();
                    initGodRays();
                    playMusic('victoryMusic');
                }
                showToast(`🏆 +${BOSS_SCORE_BONUS}`, game.player.x, game.player.y, 'updateBoss');
            }
        }
        function updateMouseDirection(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const dx = mouseX - canvas.width / 2;
            const dy = mouseY - canvas.height / 2;
            const angle = Math.atan2(dy, dx);
            game.player.direction = angle;
            game.isMoving = true;
        }
        function stopMovement() {
            game.isMoving = false;
        }
        function playSound(soundName, volume = 1, pitchVariation = 0) {
            if (!loadedAssets.sounds[soundName]) {
                console.warn(`Sound "${soundName}" not found`);
                return;
            }
            if (!audioPool[soundName]) {
                audioPool[soundName] = [];
            }
            let sound;
            for (let i = 0; i < audioPool[soundName].length; i++) {
                if (audioPool[soundName][i].ended || audioPool[soundName][i].paused) {
                    sound = audioPool[soundName][i];
                    break;
                }
            }
            if (!sound) {
                sound = loadedAssets.sounds[soundName].cloneNode();
                audioPool[soundName].push(sound);
            }
            const volumeSlider = soundName === 'bgMusic' || soundName === 'victoryMusic' ? musicVolumeSlider : sfxVolumeSlider;
            sound.volume = volume * (parseFloat(volumeSlider.value) / 100);
            if (pitchVariation !== 0) {
                sound.preservesPitch = false;
                sound.playbackRate = 1 + (Math.random() * 2 - 1) * pitchVariation;
            }
            sound.currentTime = 0;
            if (sound.paused) {
                sound.play().then(() => {
                }).catch(error => {
                    if (error.name === 'AbortError') {
                        console.warn(`Play request for sound "${soundName}" was interrupted. Retrying...`);
                        setTimeout(() => {
                            if (sound.paused) {
                                sound.play().then(() => {
                                }).catch(err => console.error(`Failed to play sound "${soundName}" after retry:`, err));
                            }
                        }, 50);
                    } else {
                        console.error(`Failed to play sound "${soundName}":`, error);
                    }
                });
            } else {
                console.warn(`Sound ${soundName} is already playing or not in a paused state`);
            }
        }
        const bloodDrops = [];
        function createBloodDrops(count) {
            for (let i = 0; i < count; i++) {
                bloodDrops.push({
                    x: Math.random() * canvas.width,
                    y: -Math.random() * canvas.height - 20,
                    speed: 2 + Math.random() * 2,
                    length: 10 + Math.random() * 10
                });
            }
        }
        function updateBloodDrops() {
            const fixedSpeed = 2;
            bloodDrops.forEach(drop => {
                drop.y += fixedSpeed + Math.random() * 2;
                if (drop.y > canvas.height) {
                    drop.y = -drop.length;
                    drop.x = Math.random() * canvas.width;
                }
            });
        }
        function drawBloodDrops() {
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 2;
            bloodDrops.forEach(drop => {
                ctx.beginPath();
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x, drop.y + drop.length);
                ctx.stroke();
            });
            ctx.restore();
        }
        let godRays = [];
        const GOD_RAY_COUNT = 8;
        const GOD_RAY_MIN_WIDTH = 50;
        const GOD_RAY_MAX_WIDTH = 200;
        const GOD_RAY_MIN_SPEED = 0.2;
        const GOD_RAY_MAX_SPEED = 1;
        function initGodRays() {
            godRays = [];
            for (let i = 0; i < GOD_RAY_COUNT; i++) {
                godRays.push({
                    x: Math.random() * canvas.width,
                    width: GOD_RAY_MIN_WIDTH + Math.random() * (GOD_RAY_MAX_WIDTH - GOD_RAY_MIN_WIDTH),
                    opacity: 0.1 + Math.random() * 0.2,
                    speed: GOD_RAY_MIN_SPEED + Math.random() * (GOD_RAY_MAX_SPEED - GOD_RAY_MIN_SPEED),
                    phaseOffset: Math.random() * Math.PI * 2
                });
            }
        }
        function updateGodRays(deltaTime) {
            godRays.forEach(ray => {
                ray.x += ray.speed * deltaTime;
                if (ray.x > canvas.width + ray.width) {
                    ray.x = -ray.width;
                }
                ray.opacity = 0.1 + Math.sin(game.gameTime * 2 + ray.phaseOffset) * 0.1;
            });
        }
        function drawGodRays() {
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            godRays.forEach(ray => {
                const gradient = ctx.createLinearGradient(ray.x, 0, ray.x + ray.width, 0);
                gradient.addColorStop(0, `rgba(255, 255, 200, 0)`);
                gradient.addColorStop(0.5, `rgba(255, 255, 200, ${ray.opacity})`);
                gradient.addColorStop(1, `rgba(255, 255, 200, 0)`);
                ctx.fillStyle = gradient;
                ctx.fillRect(ray.x, 0, ray.width, canvas.height);
            });
            ctx.restore();
        }
        const healthSlider = document.getElementById('health');
        healthSlider.addEventListener('input', () => {
            game.player.health = parseInt(healthSlider.value);
            updateHealthDisplay();
            document.body.classList.add('yellow-text');
            if (game.player.health === 0) {
                gameOver();
                playSound('death', 1, 0);
            }
        });
        let musicPlayTimeout;
        function playMusic(musicName, volume = 1) {
            if (!loadedAssets.sounds[musicName]) {
                console.warn(`Music "${musicName}" not found`);
                return Promise.resolve();
            }
            if (loadedAssets.sounds.currentBgMusic) {
                loadedAssets.sounds.currentBgMusic.pause();
                loadedAssets.sounds.currentBgMusic.currentTime = 0;
            }
            const music = loadedAssets.sounds[musicName];
            const volumeSlider = musicVolumeSlider;
            music.volume = volume * (parseFloat(volumeSlider.value) / 100);
            music.loop = true;
            loadedAssets.sounds.currentBgMusic = music;
            music.preservesPitch = false;
            music.playbackRate = 1.2;
            return new Promise((resolve, reject) => {
                const playAttempt = music.play();
                if (playAttempt) {
                    playAttempt.then(resolve).catch(error => {
                        if (error.name === 'NotAllowedError') {
                            console.warn('Autoplay prevented. Music will play on user interaction.');
                            resolve();
                        } else if (error.name === 'AbortError') {
                            console.warn('Play request was interrupted. Retrying...');
                            setTimeout(() => {
                                music.play().then(resolve).catch(reject);
                            }, 100);
                        } else {
                            reject(error);
                        }
                    });
                } else {
                    resolve();
                }
            });
        }
        function enableAudio() {
            if (loadedAssets.sounds.currentBgMusic && loadedAssets.sounds.currentBgMusic.paused) {
                playMusic(loadedAssets.sounds.currentBgMusic === loadedAssets.sounds.bgMusic ? 'bgMusic' : 'bossMusic')
                    .catch(error => console.error('Failed to play music after user interaction:', error));
            }
            document.removeEventListener('touchstart', enableAudio);
            document.removeEventListener('click', enableAudio);
        }
        musicVolumeSlider.addEventListener('input', updateVolume);
        sfxVolumeSlider.addEventListener('input', updateVolume);
        function updateVolume() {
            const volume = parseFloat(this.value) / 100;
            if (this.id === 'music-volume' && loadedAssets.sounds.currentBgMusic) {
                loadedAssets.sounds.currentBgMusic.volume = volume;
            } else {
                Object.values(loadedAssets.sounds).forEach(sound => {
                    if (sound !== loadedAssets.sounds.bgMusic) {
                        sound.volume = volume;
                    }
                });
            }
        }
        immortalityCheckbox.addEventListener('change', () => {
            document.body.classList.add('yellow-text');
        });
        function initEventListeners() {
            const canvas = document.getElementById('game-canvas');
            const playBtn = document.getElementById('play-btn');
            const restartBtn = document.getElementById('restart-btn');
            const settingsGear = document.getElementById('settings-gear');
            const backBtn = document.getElementById('back-btn');
            const healthSlider = document.getElementById('health');
            const musicVolumeSlider = document.getElementById('music-volume');
            const sfxVolumeSlider = document.getElementById('sfx-volume');
            const immortalityCheckbox = document.getElementById('immortality');
            const autoprayCheckbox = document.getElementById('autopray');
            const fpsMeterCheckbox = document.getElementById('fps-meter-checkbox');
            const fpsValue = document.getElementById('fps-value');
            const cheatUpgrades = document.getElementById('cheat-upgrades');
            const scoreDisplay = document.getElementById('score');
            const settingsScreen = document.getElementById('settings-screen');
            const introScreen = document.getElementById('intro-screen');
            const gameOverScreen = document.getElementById('game-over');
            const upgradeScreen = document.getElementById('upgrade-screen');
            window.addEventListener('load', resizeCanvas);
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('resize', handleMobileLayout);
            playBtn.addEventListener('click', startGame);
            restartBtn.addEventListener('click', restartGame);
            settingsGear.addEventListener('click', () => {
                if (settingsScreen.style.display === 'block') {
                    hideSettings();
                } else if (currentState === GameState.UPGRADING) {
                    return;
                } else {
                    showSettings();
                }
            });
            backBtn.addEventListener('click', hideSettings);
            healthSlider.addEventListener('input', () => {
                game.player.health = parseInt(healthSlider.value);
                updateHealthDisplay();
                document.body.classList.add('yellow-text');
                if (game.player.health === 0) {
                    gameOver();
                }
            });
            musicVolumeSlider.addEventListener('input', () => {
                if (loadedAssets.sounds.currentBgMusic) {
                    loadedAssets.sounds.currentBgMusic.volume = parseFloat(musicVolumeSlider.value) / 100;
                }
            });
            sfxVolumeSlider.addEventListener('input', () => {
                Object.values(loadedAssets.sounds).forEach(sound => {
                    if (sound !== loadedAssets.sounds.bgMusic) {
                        sound.volume = parseFloat(sfxVolumeSlider.value) / 100;
                    }
                });
            });
            immortalityCheckbox.addEventListener('change', () => {
                document.body.classList.add('yellow-text');
            });
            autoprayCheckbox.addEventListener('change', function () {
                AUTOPRAY = this.checked;
                document.body.classList.add('yellow-text');
            });
            fpsMeterCheckbox.addEventListener('change', function () {
                fpsDisplayEnabled = this.checked;
                document.getElementById('fps-meter').style.display = fpsDisplayEnabled ? 'block' : 'none';
            });
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && currentState === GameState.PLAYING) {
                    e.preventDefault();
                    prayer();
                    PRAYED = true;
                    RESTED = false;
                }
                if (e.code === 'Escape') {
                    if (settingsScreen.style.display === 'block') {
                        hideSettings();
                    } else if (currentState === GameState.GAME_OVER) {
                        restartGame();
                    } else if (currentState === GameState.UPGRADING) {
                        return;
                    } else {
                        showSettings();
                    }
                }
            });
            document.addEventListener('keyup', (e) => {
                if (e.code === 'Space' && PRAYED) {
                    RESTED = true;
                }
            });
            canvas.addEventListener('mousedown', e => {
                game.isMouseDown = true;
                updateMouseDirection(e);
            });
            canvas.addEventListener('mousemove', e => {
                if (game.isMouseDown) updateMouseDirection(e);
            });
            canvas.addEventListener('mouseup', () => {
                game.isMouseDown = false;
                stopMovement();
            });
            window.addEventListener('resize', updatePrayerBarWidth);
        }
        function showSettings() {
            if (currentState === GameState.PLAYING) {
                currentState = GameState.PAUSED;
            }
            settingsScreen.style.display = 'block';
            cheatUpgrades.innerHTML = '';
            const upgradeNames = {
                projectiles: 'Projectiles',
                speed: 'Speed',
                firerate: 'Fire Rate',
                pierce: 'Pierce',
                size: 'Projectile Size',
                range: 'Range',
                prayer: 'Prayer'
            };
            const cheatScoreItem = document.createElement('div');
            cheatScoreItem.className = 'cheat-item';
            const span = document.createElement('span');
            span.textContent = '🏆 Score:';
            cheatScoreItem.appendChild(span);
            const cheatScoreInput = document.createElement('input');
            cheatScoreInput.type = 'number';
            cheatScoreInput.id = 'cheat-score';
            cheatScoreInput.value = game.score;
            cheatScoreInput.min = 0;
            cheatScoreItem.appendChild(cheatScoreInput);
            cheatScoreInput.addEventListener('change', () => {
                game.score = parseInt(cheatScoreInput.value, 10);
                scoreDisplay.textContent = game.score;
                document.body.classList.add('yellow-text');
            });
            cheatUpgrades.appendChild(cheatScoreItem);
            for (const [key, value] of Object.entries(game.playerUpgrades)) {
                const cheatItem = document.createElement('div');
                cheatItem.className = 'cheat-item';
                const span = document.createElement('span');
                span.textContent = `${upgradeEmojis[key]} ${upgradeNames[key]}:`;
                cheatItem.appendChild(span);
                const input = document.createElement('input');
                input.type = 'number';
                input.value = value;
                input.min = 1;
                input.max = 99;
                input.addEventListener('change', () => {
                    game.playerUpgrades[key] = parseInt(input.value, 10);
                    updateUpgradesList();
                    document.body.classList.add('yellow-text');
                    if (key === 'speed') {
                        game.player.speed = game.defaultSpeed * game.playerUpgrades.speed;
                    }
                    if (key === 'firerate') {
                        clearInterval(game.fireInterval);
                        game.fireInterval = setInterval(shoot, 400 / game.playerUpgrades.firerate);
                    }
                });
                cheatItem.appendChild(input);
                cheatUpgrades.appendChild(cheatItem);
            }
            const dropRateItem = document.createElement('div');
            dropRateItem.className = 'cheat-item';
            dropRateItem.innerHTML = `
        <label for="drop-rate">🎁 Drop Rate:</label>
        <input type="number" id="drop-rate" min="0" max="1" step="0.01" value="${PICKUP_DROP_RATE.toFixed(2)}">
    `;
            cheatUpgrades.appendChild(dropRateItem);
            const cheatBossItem = document.createElement('div');
            cheatBossItem.className = 'cheat-item';
            const spanBoss = document.createElement('span');
            spanBoss.textContent = '👾 Spawn Boss:';
            cheatBossItem.appendChild(spanBoss);
            const bossButton = document.createElement('button');
            bossButton.textContent = '🧛‍♂️';
            bossButton.className = 'button';
            bossButton.style.width = '60px';
            bossButton.style.height = '30px';
            bossButton.style.padding = '0';
            bossButton.style.lineHeight = '30px';
            bossButton.onclick = () => {
                spawnBossCheat();
                document.body.classList.add('yellow-text');
            };
            cheatBossItem.appendChild(bossButton);
            cheatUpgrades.appendChild(cheatBossItem);
            const dropRateInput = document.getElementById('drop-rate');
            dropRateInput.addEventListener('input', () => {
                PICKUP_DROP_RATE = parseFloat(dropRateInput.value);
                document.body.classList.add('yellow-text');
            });
            document.getElementById('fps-meter-checkbox').addEventListener('change', function () {
                fpsDisplayEnabled = this.checked;
                const fpsMeter = document.getElementById('fps-meter');
                if (fpsMeter) {
                    fpsMeter.style.display = fpsDisplayEnabled ? 'block' : 'none';
                }
            });
            if (game.player.invulnerable) {
                document.body.classList.add('hurt');
                game.remainingInvulnerabilityTime = game.invulnerabilityEndTime - performance.now();
            }
        }
        function hideSettings() {
            settingsScreen.style.display = 'none';
            if (currentState === GameState.INTRO || currentState === GameState.UPGRADING) {
                return;
            }
            if (currentState === GameState.PAUSED) {
                currentState = GameState.PLAYING;
            }
            if (game.player.invulnerable) {
                document.body.classList.add('hurt');
                game.invulnerabilityEndTime = performance.now() + game.remainingInvulnerabilityTime;
            }
        }
        document.addEventListener('DOMContentLoaded', function () {
            loadAssets(() => {
                currentState = GameState.INTRO;
                loadingScreen.style.display = 'none';
                introScreen.style.display = 'block';
                initEventListeners();
                resizeCanvas();
                handleMobileLayout();
                updateHealthDisplay();
                updatePrayerCooldown();
                updatePrayerBarWidth();
                createBloodDrops(100);
                addClickSoundToButtons();
                document.getElementById('fps-meter').style.display = 'none';
                requestAnimationFrame(updateGame);
                document.addEventListener('touchstart', enableAudio);
                document.addEventListener('click', enableAudio);
                playMusic('bgMusic').catch(error => console.error('Initial music play failed:', error));
                const playMusicBtn = document.getElementById('play-music-btn');
                playMusicBtn.addEventListener('click', () => {
                    playMusic('bgMusic')
                        .catch(error => console.error('Failed to play background music:', error));
                });
            });
        });
    </script>
</body>

</html>