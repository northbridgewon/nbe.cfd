<html><head><base href="https://advancedpaintapp.com/" /><title>Advanced Paint App</title><style>
  body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    font-family: Arial, sans-serif;
    overflow: hidden;
  }
  #app {
    display: grid;
    grid-template-columns: 80px 1fr 200px;
    grid-template-rows: auto 1fr;
    height: 100vh;
  }
  #toolbar {
    grid-column: 1 / -1;
    background-color: #f0f0f0;
    padding: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #ccc;
  }
  #tools {
    grid-column: 1;
    grid-row: 2;
    background-color: #e0e0e0;
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    overflow-y: auto;
  }
  #canvas-container {
    grid-column: 2;
    grid-row: 2;
    overflow: auto;
    background-color: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  #color-panel {
    grid-column: 3;
    grid-row: 2;
    background-color: #e0e0e0;
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    overflow-y: auto;
  }
  #canvas {
    border: 1px solid #000;
    cursor: crosshair;
  }
  .tool-btn {
    padding: 5px;
    background-color: #fff;
    border: 1px solid #999;
    cursor: pointer;
    text-align: center;
  }
  .tool-btn:hover {
    background-color: #e6e6e6;
  }
  .tool-btn.active {
    background-color: #ccc;
  }
  #color-preview {
    width: 100%;
    height: 50px;
    border: 1px solid #999;
    margin-top: 10px;
  }
  #brush-size {
    width: 100%;
    margin-top: 10px;
  }
  .color-swatch {
    width: 30px;
    height: 30px;
    margin: 2px;
    border: 1px solid #999;
    cursor: pointer;
    display: inline-block;
  }
  #custom-colors {
    display: flex;
    flex-wrap: wrap;
  }
</style></head><body>
<div id="app">
  <div id="toolbar">
    <div>
      <button onclick="clearCanvas()">New</button>
      <button onclick="undo()">Undo</button>
      <button onclick="redo()">Redo</button>
      <button onclick="saveImage()">Save</button>
      <input type="file" id="load-image" accept="image/*" onchange="loadImage(event)" style="display:none;">
      <button onclick="document.getElementById('load-image').click()">Load Image</button>
    </div>
    <div>
      <label for="canvas-width">Width:</label>
      <input type="number" id="canvas-width" value="800" min="1" max="2000" onchange="resizeCanvas()">
      <label for="canvas-height">Height:</label>
      <input type="number" id="canvas-height" value="600" min="1" max="2000" onchange="resizeCanvas()">
    </div>
    <div>
      <button onclick="zoomIn()">Zoom In</button>
      <button onclick="zoomOut()">Zoom Out</button>
      <span id="zoom-level">100%</span>
    </div>
  </div>
  <div id="tools">
    <button class="tool-btn active" onclick="selectTool('brush')">üñåÔ∏è Brush</button>
    <button class="tool-btn" onclick="selectTool('eraser')">üßΩ Eraser</button>
    <button class="tool-btn" onclick="selectTool('fill')">ü™£ Fill</button>
    <label for="brush-size">Brush Size:</label>
    <input type="range" id="brush-size" min="1" max="50" value="5" onchange="setBrushSize(this.value)">
    <span id="brush-size-display">5px</span>
  </div>
  <div id="canvas-container">
    <canvas id="canvas" width="800" height="600"></canvas>
  </div>
  <div id="color-panel">
    <div id="color-preview"></div>
    <input type="color" id="color-picker" onchange="setColor(this.value)">
    <div id="preset-colors"></div>
    <div id="custom-colors"></div>
    <button onclick="addCustomColor()">Add Custom Color</button>
  </div>
</div>

<script>
let currentColor = '#000000';
let currentTool = 'brush';
let brushSize = 5;
let isDrawing = false;
let ctx;
let canvas;
let undoStack = [];
let redoStack = [];
let zoomLevel = 1;

const presetColors = [
  '#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#00FFFF', '#FF00FF',
  '#C0C0C0', '#808080', '#800000', '#808000', '#008000', '#800080', '#008080', '#000080'
];

const customColors = [];

window.onload = function() {
  canvas = document.getElementById('canvas');
  ctx = canvas.getContext('2d');
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  
  initColorPalette();
  setColor('#000000');
  
  canvas.addEventListener('mousedown', startDrawing);
  canvas.addEventListener('mousemove', draw);
  canvas.addEventListener('mouseup', stopDrawing);
  canvas.addEventListener('mouseout', stopDrawing);

  saveCanvasState();
}

function initColorPalette() {
  const presetPalette = document.getElementById('preset-colors');
  presetColors.forEach(color => {
    const swatch = createColorSwatch(color);
    presetPalette.appendChild(swatch);
  });
}

function createColorSwatch(color) {
  const swatch = document.createElement('div');
  swatch.className = 'color-swatch';
  swatch.style.backgroundColor = color;
  swatch.onclick = () => setColor(color);
  return swatch;
}

function setColor(color) {
  currentColor = color;
  document.getElementById('color-preview').style.backgroundColor = color;
  document.getElementById('color-picker').value = color;
}

function selectTool(tool) {
  currentTool = tool;
  document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
  event.target.classList.add('active');
}

function setBrushSize(size) {
  brushSize = size;
  document.getElementById('brush-size-display').textContent = size + 'px';
}

function startDrawing(e) {
  isDrawing = true;
  draw(e);
}

function draw(e) {
  if (!isDrawing) return;
  
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / zoomLevel;
  const y = (e.clientY - rect.top) / zoomLevel;
  
  ctx.lineWidth = brushSize;
  
  if (currentTool === 'brush') {
    ctx.strokeStyle = currentColor;
    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x, y);
  } else if (currentTool === 'eraser') {
    ctx.strokeStyle = '#FFFFFF';
    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x, y);
  } else if (currentTool === 'fill') {
    floodFill(Math.floor(x), Math.floor(y), currentColor);
  }
}

function stopDrawing() {
  if (isDrawing) {
    isDrawing = false;
    ctx.beginPath();
    saveCanvasState();
  }
}

function clearCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  saveCanvasState();
}

function saveImage() {
  const link = document.createElement('a');
  link.download = 'drawing.png';
  link.href = canvas.toDataURL();
  link.click();
}

function loadImage(event) {
  const file = event.target.files[0];
  const reader = new FileReader();
  reader.onload = function(event) {
    const img = new Image();
    img.onload = function() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      saveCanvasState();
    }
    img.src = event.target.result;
  }
  reader.readAsDataURL(file);
}

function floodFill(x, y, fillColor) {
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const targetColor = getPixelColor(imageData, x, y);
  
  if (colorsMatch(targetColor, hexToRgb(fillColor))) return;
  
  const pixelsToCheck = [x, y];
  while (pixelsToCheck.length > 0) {
    const y = pixelsToCheck.pop();
    const x = pixelsToCheck.pop();
    
    const currentColor = getPixelColor(imageData, x, y);
    if (colorsMatch(currentColor, targetColor)) {
      setPixelColor(imageData, x, y, hexToRgb(fillColor));
      pixelsToCheck.push(x + 1, y);
      pixelsToCheck.push(x - 1, y);
      pixelsToCheck.push(x, y + 1);
      pixelsToCheck.push(x, y - 1);
    }
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function getPixelColor(imageData, x, y) {
  const index = (y * imageData.width + x) * 4;
  return {
    r: imageData.data[index],
    g: imageData.data[index + 1],
    b: imageData.data[index + 2],
    a: imageData.data[index + 3]
  };
}

function setPixelColor(imageData, x, y, color) {
  const index = (y * imageData.width + x) * 4;
  imageData.data[index] = color.r;
  imageData.data[index + 1] = color.g;
  imageData.data[index + 2] = color.b;
  imageData.data[index + 3] = 255;
}

function colorsMatch(color1, color2) {
  return color1.r === color2.r && color1.g === color2.g && color1.b === color2.b;
}

function hexToRgb(hex) {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}

function resizeCanvas() {
  const width = document.getElementById('canvas-width').value;
  const height = document.getElementById('canvas-height').value;
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  canvas.width = width;
  canvas.height = height;
  ctx.putImageData(imageData, 0, 0);
  saveCanvasState();
}

function zoomIn() {
  zoomLevel *= 1.1;
  applyZoom();
}

function zoomOut() {
  zoomLevel /= 1.1;
  applyZoom();
}

function applyZoom() {
  canvas.style.transform = `scale(${zoomLevel})`;
  document.getElementById('zoom-level').textContent = `${Math.round(zoomLevel * 100)}%`;
}

function saveCanvasState() {
  undoStack.push(canvas.toDataURL());
  redoStack = [];
}

function undo() {
  if (undoStack.length > 1) {
    redoStack.push(undoStack.pop());
    const img = new Image();
    img.onload = function() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);
    }
    img.src = undoStack[undoStack.length - 1];
  }
}

function redo() {
  if (redoStack.length > 0) {
    const img = new Image();
    img.onload = function() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);
      undoStack.push(redoStack.pop());
    }
    img.src = redoStack[redoStack.length - 1];
  }
}

function addCustomColor() {
  const color = document.getElementById('color-picker').value;
  if (!customColors.includes(color)) {
    customColors.push(color);
    const swatch = createColorSwatch(color);
    document.getElementById('custom-colors').appendChild(swatch);
  }
}
</script>
</body></html>