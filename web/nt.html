<html><head><base href="https://websim.ai" />
<title>NEON TETRIS</title>
<style>
  body {
    font-family: 'Press Start 2P', cursive;
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background: linear-gradient(45deg, #ff00ff, #00ffff, #ff00ff, #00ffff);
    background-size: 400% 400%;
    animation: gradientBG 15s ease infinite;
    overflow: hidden;
  }
  @keyframes gradientBG {
    0% {background-position: 0% 50%;}
    50% {background-position: 100% 50%;}
    100% {background-position: 0% 50%;}
  }
  .game-container {
    background-color: rgba(0, 0, 0, 0.7);
    border-radius: 20px;
    box-shadow: 0 0 30px rgba(255,255,255,0.3);
    padding: 30px;
    text-align: center;
  }
  h1 {
    color: #fff;
    text-shadow: 0 0 10px #ff00de, 0 0 20px #ff00de, 0 0 30px #ff00de;
    margin-bottom: 20px;
    font-size: 2.5em;
    animation: neonFlicker 1.5s infinite alternate;
  }
  @keyframes neonFlicker {
    0%, 18%, 22%, 25%, 53%, 57%, 100% {
      text-shadow: 0 0 10px #ff00de, 0 0 20px #ff00de, 0 0 30px #ff00de, 0 0 40px #ff00de;
    }
    20%, 24%, 55% {       
      text-shadow: none;
    }
  }
  #tetris-canvas {
    border: 3px solid #fff;
    box-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
  }
  #score {
    font-size: 1.5em;
    margin-top: 20px;
    color: #fff;
    text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
  }
  #start-button {
    background-color: #ff00de;
    border: none;
    color: white;
    padding: 15px 32px;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 1em;
    margin: 20px 2px;
    cursor: pointer;
    border-radius: 5px;
    font-family: 'Press Start 2P', cursive;
    transition: all 0.3s;
    text-shadow: 0 0 10px #ff00de, 0 0 20px #ff00de;
    box-shadow: 0 0 20px #ff00de;
  }
  #start-button:hover {
    background-color: #00ffff;
    text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
    box-shadow: 0 0 20px #00ffff;
  }
  #controls {
    color: #fff;
    margin-top: 20px;
    font-size: 0.8em;
    text-shadow: 0 0 5px #00ffff;
  }
</style>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
<div class="game-container">
  <h1>NEON TETRIS</h1>
  <canvas id="tetris-canvas" width="240" height="400"></canvas>
  <div id="score">Score: 0</div>
  <button id="start-button">Start Game</button>
  <div id="controls">
    ← → : Move | ↑ : Rotate | ↓ : Soft Drop<br>
    SPACE : Hard Drop
  </div>
</div>

<script>
const canvas = document.getElementById('tetris-canvas');
const context = canvas.getContext('2d');
const scoreElement = document.getElementById('score');
const startButton = document.getElementById('start-button');

const ROWS = 20;
const COLS = 12;
const BLOCK_SIZE = 20;

let score = 0;
let board = [];
let currentPiece;
let gameInterval;

const SHAPES = [
  [[1,1,1,1]],
  [[1,1],[1,1]],
  [[1,1,1],[0,1,0]],
  [[1,1,1],[1,0,0]],
  [[1,1,1],[0,0,1]],
  [[1,1,0],[0,1,1]],
  [[0,1,1],[1,1,0]]
];

const COLORS = [
  '#ff00ff',
  '#00ffff',
  '#ffff00',
  '#ff8000',
  '#0080ff',
  '#00ff80',
  '#ff0080'
];

// PC Speaker Sound Effects
const audioContext = new (window.AudioContext || window.webkitAudioContext)();

function playTone(frequency, duration) {
  const oscillator = audioContext.createOscillator();
  oscillator.type = 'square';
  oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
  
  const gainNode = audioContext.createGain();
  gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
  gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration);

  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  
  oscillator.start();
  oscillator.stop(audioContext.currentTime + duration);
}

function playMoveSound() {
  playTone(220, 0.05);
}

function playRotateSound() {
  playTone(440, 0.05);
}

function playLockSound() {
  playTone(330, 0.1);
}

function playClearSound() {
  playTone(660, 0.15);
}

function playHardDropSound() {
  playTone(880, 0.1);
}

function playGameOverSound() {
  playTone(110, 0.3);
  setTimeout(() => playTone(82.41, 0.3), 300);
}

function initBoard() {
  for (let r = 0; r < ROWS; r++) {
    board[r] = [];
    for (let c = 0; c < COLS; c++) {
      board[r][c] = 0;
    }
  }
}

function drawBlock(x, y, color) {
  context.fillStyle = color;
  context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
  context.strokeStyle = "#fff";
  context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
  
  // Add neon glow effect
  context.shadowBlur = 10;
  context.shadowColor = color;
  context.fillRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
  context.shadowBlur = 0;
}

function drawBoard() {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (board[r][c]) {
        drawBlock(c, r, COLORS[board[r][c] - 1]);
      }
    }
  }
}

function createPiece() {
  let pieceIndex = Math.floor(Math.random() * SHAPES.length);
  let piece = SHAPES[pieceIndex];
  return {
    shape: piece,
    color: COLORS[pieceIndex],
    x: Math.floor(COLS / 2) - Math.ceil(piece[0].length / 2),
    y: 0
  };
}

function drawPiece() {
  for (let r = 0; r < currentPiece.shape.length; r++) {
    for (let c = 0; c < currentPiece.shape[r].length; c++) {
      if (currentPiece.shape[r][c]) {
        drawBlock(currentPiece.x + c, currentPiece.y + r, currentPiece.color);
      }
    }
  }
}

function moveDown() {
  if (!collision(0, 1)) {
    currentPiece.y++;
    playMoveSound();
  } else {
    lockPiece();
    clearLines();
    currentPiece = createPiece();
    if (collision(0, 0)) {
      gameOver();
    }
  }
}

function moveLeft() {
  if (!collision(-1, 0)) {
    currentPiece.x--;
    playMoveSound();
  }
}

function moveRight() {
  if (!collision(1, 0)) {
    currentPiece.x++;
    playMoveSound();
  }
}

function rotate() {
  let newShape = [];
  for (let c = 0; c < currentPiece.shape[0].length; c++) {
    newShape.push([]);
    for (let r = currentPiece.shape.length - 1; r >= 0; r--) {
      newShape[c].push(currentPiece.shape[r][c]);
    }
  }
  
  let previousShape = currentPiece.shape;
  currentPiece.shape = newShape;
  
  if (collision(0, 0)) {
    currentPiece.shape = previousShape;
  } else {
    playRotateSound();
  }
}

function hardDrop() {
  let dropDistance = 0;
  while (!collision(0, dropDistance + 1)) {
    dropDistance++;
  }
  currentPiece.y += dropDistance;
  lockPiece();
  clearLines();
  currentPiece = createPiece();
  if (collision(0, 0)) {
    gameOver();
  }
  playHardDropSound();
}

function collision(x, y) {
  for (let r = 0; r < currentPiece.shape.length; r++) {
    for (let c = 0; c < currentPiece.shape[r].length; c++) {
      if (!currentPiece.shape[r][c]) {
        continue;
      }
      let newX = currentPiece.x + c + x;
      let newY = currentPiece.y + r + y;
      if (newX < 0 || newX >= COLS || newY >= ROWS) {
        return true;
      }
      if (newY < 0) {
        continue;
      }
      if (board[newY][newX]) {
        return true;
      }
    }
  }
  return false;
}

function lockPiece() {
  for (let r = 0; r < currentPiece.shape.length; r++) {
    for (let c = 0; c < currentPiece.shape[r].length; c++) {
      if (currentPiece.shape[r][c]) {
        let pieceColor = COLORS.indexOf(currentPiece.color) + 1;
        board[currentPiece.y + r][currentPiece.x + c] = pieceColor;
      }
    }
  }
  playLockSound();
}

function clearLines() {
  let linesToClear = [];
  for (let r = ROWS - 1; r >= 0; r--) {
    if (board[r].every(cell => cell !== 0)) {
      linesToClear.push(r);
    }
  }
  
  if (linesToClear.length > 0) {
    playClearSound();
    animateClearLines(linesToClear);
  }
}

function animateClearLines(lines) {
  let animationFrames = 5;
  let frameCount = 0;

  function animate() {
    if (frameCount >= animationFrames) {
      // Animation complete, remove lines and update score
      lines.forEach(line => {
        board.splice(line, 1);
        board.unshift(Array(COLS).fill(0));
      });
      score += lines.length * 100;
      scoreElement.textContent = `Score: ${score}`;
      return;
    }

    // Draw flashing effect
    lines.forEach(line => {
      const color = frameCount % 2 === 0 ? '#ffffff' : '#000000';
      context.fillStyle = color;
      context.fillRect(0, line * BLOCK_SIZE, canvas.width, BLOCK_SIZE);
    });

    frameCount++;
    requestAnimationFrame(animate);
  }

  animate();
}

function gameOver() {
  clearInterval(gameInterval);
  context.fillStyle = "rgba(0, 0, 0, 0.7)";
  context.fillRect(0, 0, canvas.width, canvas.height);
  context.fillStyle = "#ff00de";
  context.font = "20px 'Press Start 2P'";
  context.textAlign = "center";
  context.fillText("Game Over", canvas.width / 2, canvas.height / 2);
  context.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 40);
  startButton.style.display = "inline-block";
  playGameOverSound();
}

function gameLoop() {
  context.clearRect(0, 0, canvas.width, canvas.height);
  drawBoard();
  drawPiece();
  drawScanlines();
}

function startGame() {
  initBoard();
  score = 0;
  scoreElement.textContent = "Score: 0";
  currentPiece = createPiece();
  startButton.style.display = "none";
  if (gameInterval) {
    clearInterval(gameInterval);
  }
  gameInterval = setInterval(() => {
    moveDown();
    gameLoop();
  }, 500);
}

document.addEventListener('keydown', event => {
  switch(event.keyCode) {
    case 37: // Left arrow
      moveLeft();
      break;
    case 39: // Right arrow
      moveRight();
      break;
    case 40: // Down arrow
      moveDown();
      break;
    case 38: // Up arrow
      rotate();
      break;
    case 32: // Space bar
      hardDrop();
      break;
  }
  gameLoop();
});

startButton.addEventListener('click', startGame);

// Add some retro scanlines effect
function drawScanlines() {
  context.fillStyle = "rgba(255,255,255,0.1)";
  for(let i = 0; i < canvas.height; i += 4) {
    context.fillRect(0, i, canvas.width, 2);
  }
}

</script>
</body></html>